[Experimenter 3] 10:47:06
And for the next section, I'm going to run the computer and share the screen.

[Experimenter 3] 10:47:14
And you'll still be able to draw on the paper if you'd like.

[Experimenter 3] 10:47:19
Though I think largely we'll refer to just the screen.

[Experimenter 3] 10:47:30
Share my folder.

[Experimenter 3] 10:47:45
Okay.

[Experimenter 3] 10:47:48
This probably looks familiar.

[Experimenter 3] 10:47:52
So now we're going to cover some open-ended questions that are intended to enable us to construct

[Experimenter 3] 10:47:58
what's called a fuzzy cognitive map.

[Experimenter 3] 10:48:02
related to cyber attacks and cyber attackers, knowledge, beliefs, and decisions.

[Experimenter 3] 10:48:07
As before, there are no predefined correct answers to these questions.

[Experimenter 3] 10:48:12
This is an iterative and open-ended process. It's a semi-structured

[Experimenter 3] 10:48:17
While it follows a very basic structure of the types of questions that are asked.

[Experimenter 3] 10:48:23
We also may use, and in this case we are using computer visualization software to

[Experimenter 3] 10:48:28
make it easy to diagram and draw out this process.

[Experimenter 3] 10:48:32
So just please respond given your experiences and based on your understanding of what we're going through here.

[Experimenter 3] 10:48:43
So…

[Experimenter 3] 10:48:45
Here we have essentially a

[Experimenter 3] 10:48:48
initial diagram of kind of the flow that you've described this is

[Experimenter 3] 10:48:52
expressly looking at the forward flow and iteration between steps.

[Experimenter 3] 10:48:57
As opposed to the

[Experimenter 3] 10:49:00
also the backward flow.

[Experimenter 3] 10:49:02
from one category to the previous.

[Experimenter 3] 10:49:07
This graph, to give you a little bit of context, is

[Experimenter 3] 10:49:11
a signed graph. So essentially success in this step reinforces or strengthens success in the next step.

[Experimenter 3] 10:49:20
If this makes the next step harder or worse, then we'll make it

[Experimenter 3] 10:49:24
negative and it'll be red instead. And if it's neutral or mixed, like it could be

[Experimenter 3] 10:49:29
success here could be good, could be bad for the next thing, then we can bring it to zero.

[Experimenter 3] 10:49:35
So by default, success in these, since this is getting you to here.

[Experimenter 3] 10:49:41
These are all positives.

[Experimenter 3] 10:49:44
So I want to dig into these steps and uh

[Experimenter 3] 10:49:49
First, understand the most important factors that affect the success of each step.

[Experimenter 3] 10:49:55
And to do so, that may involve recalling specific examples or the most common instances of what you could think of.

[Experimenter 3] 10:50:05
And so we'll basically dig into that a little bit.

[Experimenter 3] 10:50:11
So from the first step of understanding the challenge, you had mentioned some factors before.

[Experimenter 3] 10:50:16
Such as the

[Experimenter 3] 10:50:19
the text of the challenge and what the files are.

[Experimenter 3] 10:50:25
Are there specific factors within them that would lead to success or challenges with understanding the challenge?

[Participant 1] 10:50:34
Yeah, I think so. So like the um

[Participant 1] 10:50:38
Text itself can either be

[Participant 1] 10:50:41
super beneficial or make you more confused. Like it can be a red herring. So like red herrings do exist.

[Participant 1] 10:50:48
And then I think like the

[Participant 1] 10:50:53
actual like you know

[Participant 1] 10:50:56
success in reading what the

[Participant 1] 10:50:58
challenge files are success in reading the

[Participant 1] 10:51:02
Actual, like, how do you connect to this challenge

[Participant 1] 10:51:06
like that.

[Participant 1] 10:51:08
that really leads to success in part.

[Participant 1] 10:51:12
be um or i guess yeah

[Experimenter 3] 10:51:15
Okay, this one would you say maybe is really reinforces this part B? Gotcha. All righty, cool.

[Experimenter 3] 10:51:21
I'm going to just remove this edge.

[Experimenter 3] 10:51:25
And this is going to get messy. It's okay. The software will

[Experimenter 3] 10:51:31
create a basically a matrix of all of this. So as long as we can kind of interpret what we're going with it, that's okay.

[Experimenter 3] 10:51:40
Okay, so are there any specific

[Experimenter 3] 10:51:44
issues or details that might affect your judgment as to whether there is a red herring.

[Experimenter 3] 10:51:49
Or would that be discovered later? 

[Participant 1] 10:51:51
That would be discovered later. So you won't know until probably step C, D, and E.

[Experimenter 3] 10:51:57
Down here?

[Participant 1] 10:51:57
Really when that'll become more apparent.

[Experimenter 3] 10:51:59
Got it. Got it.

[Experimenter 3] 10:52:02
All right.

[Experimenter 3] 10:52:10
Would you say that's a discovery of specifically red herrings or a discovery of

[Experimenter 3] 10:52:15
really what you're actually looking for 

[Participant 1] 10:52:18
i think both like it's gonna you're going to either discover red herrings or you're going to discover

[Participant 1] 10:52:23
you know, you're going to confirm whatever

[Participant 1] 10:52:26
ideas you had about step A.

[Experimenter 3] 10:52:39
And that has a negative relationship with red herrings because it's going to 

[Participant 1] 10:52:42
get rid of them.

[Experimenter 3] 10:52:43
Right. Yep. 

[Participant 1] 10:52:43
Which is good.

[Experimenter 3] 10:52:46
Yeah. Okay. I'm going to put this down here.

[Experimenter 3] 10:52:50
And you said that also it's possible that B and C would

[Experimenter 3] 10:52:56
lead to this? 

[Participant 1] 10:52:57
Yeah, really BC and E, I would say. 

[Experimenter 3] 10:52:59
B, C, and E. Yep. Okay, so not D. 

[Participant 1] 10:53:01
And D. 

[Experimenter 3] 10:53:02
Oh, okay. 

[Participant 1] 10:53:03
D as well, yeah. 

[Experimenter 3] 10:53:04
Gotcha.

[Experimenter 3] 10:53:11
Great.

[Experimenter 3] 10:53:16
Okay, moving to this next step here.

[Experimenter 3] 10:53:21
what are some of the factors that would influence your ability to succeed in downloading files or connecting to the server?

[Participant 1] 10:53:28
whether or not you could actually successfully connect um so like a

[Participant 1] 10:53:32
you know, failed connection for permissions or for other issues.

[Participant 1] 10:53:38
And then…

[Participant 1] 10:53:40
Same with downloading the same

[Participant 1] 10:53:43
file itself, you can have permissions issues there. But

[Participant 1] 10:53:48
Along with that, it's you know

[Participant 1] 10:53:53
success like success in acquisition

[Participant 1] 10:53:57
Sims.

[Participant 1] 10:53:59
Yeah, pretty basic. I think those are the main ones. You successfully connect and you successfully download. And if there's permissions or other, like it doesn't have to be permissions issues, but it

[Participant 1] 10:54:10
Sometimes, like generally it seems to be.

[Experimenter 3] 10:54:12
Okay, if there are permission issues, what might be your next course of action?

[Participant 1] 10:54:16
That is usually when you start complaining to the organizers because really like A and B should not

[Participant 1] 10:54:22
should not fail. 

[Experimenter 1] 10:54:23
Got it. 

[Participant 1] 10:54:24
Or I guess like you can fail to understand the challenge but like the

[Experimenter 3] 10:54:27
You should be able to connect and you should be able to download files.

[Experimenter 3] 10:54:32
Got it. 

[Participant 1] 10:54:33
So that's usually a give up step. 

[Experimenter 3] 10:54:36
Okay. All right, moving to C, what are some of the factors that might influence the success of running locally or uploading to a decompiler like Idra?

[Participant 1] 10:54:46
Running locally especially can

[Participant 1] 10:54:48
vary a lot based on architecture and operating system.

[Participant 1] 10:54:53
So that can mean that it's as easy as Chimod plus Xing a file and running it.

[Participant 1] 10:55:01
Or it can be as complex as, okay, I need to emulate this and I need to, you know.

[Participant 1] 10:55:06
do a lot.

[Participant 1] 10:55:10
So I think there's those two sides. And then uploading into Gaidra similarly is under, you know, knowing the architecture like

[Participant 1] 10:55:18
understanding the architecture of the program and the memory map for it.

[Participant 1] 10:55:29
And a lot of times that means that you're your decompiler may not support the architecture or your decompiler could

[Participant 1] 10:55:37
you know, fail to decompile because you're looking at a really, really gross

[Participant 1] 10:55:42
original language like Go or Rust or crystal

[Experimenter 3] 10:55:47
Right. So yeah, you've alluded to, so what are some of the other issues that might affect the success of this? 

[Participant 1] 10:55:52
Yeah. So with both of them, it's generally just like, you know.

[Participant 1] 10:55:56
the tool does not support what you need to

[Participant 1] 10:56:01
what like the running locally or uploading

[Participant 1] 10:56:05
Yeah, tool slash system, I guess, in the case of architecture.

[Experimenter 3] 10:56:10
does not support basically the approach.

[Participant 1] 10:56:12
Yeah, the approach. 

[Experimenter 3] 10:56:13
Okay. Gotcha.

[Experimenter 3] 10:56:17
If that does occur.

[Experimenter 3] 10:56:21
what mitigation steps might you take?

[Participant 1] 10:56:24
So for the architecture and operating system side, you can certainly emulate, you can certainly

[Participant 1] 10:56:30
A lot of times that does come down to if you're trying to run a Windows binary and you have a friend that is already running Windows.

[Participant 1] 10:56:38
That's easier. But yeah, emulation or emulation

[Participant 1] 10:56:42
you know, virtual machines and

[Participant 1] 10:56:45
those two cases.

[Participant 1] 10:56:48
And then as far as Ghidra goes, a lot of times that means trying other tools.

[Experimenter 3] 10:56:54
Mm-hmm.

[Participant 1] 10:56:56
So, you know, maybe binary ninja supports this

[Participant 1] 10:56:59
Like, I'm thinking a lot of like the, you know, rusty compilation isn't as good in Ghidra as it is in some other languages.

[Participant 1] 10:57:06
So other decompilers, or occasionally you have to write your own. And usually that means writing your own disassembler, not decompiler.

[Experimenter 3] 10:57:17
So got it so

[Experimenter 3] 10:57:20
try other decompilers. 

[Participant 1] 10:57:22
Yeah.

[Experimenter 3] 10:57:24
or builds this assembler 

[Participant 1] 10:57:26
yeah

[Participant 1] 10:57:27
you're not going to have time to build a full decompiler.

[Experimenter 3] 10:57:31
All right.

[Experimenter 3] 10:57:37
from these

[Experimenter 3] 10:57:40
do you then, are you then essentially getting back to step D here?

[Participant 1] 10:57:47
Yes. 

[Experimenter 1] 10:57:47
Okay. 

[Participant 1] 10:57:48
Yep.

[Experimenter 3] 10:57:48
Gotcha. Okay. So these are basically alternatives to running locally slash uploading to Kitra.

[Participant 1] 10:57:54
Yep

[Experimenter 3] 10:57:55
or mitigations to doing so okay

[Experimenter 3] 10:57:57
Great.

[Experimenter 3] 10:58:06
Yeah.

[Experimenter 3] 10:58:09
The thing about this software is that I would really love to be able

[Experimenter 3] 10:58:11
to Zoom more effectively.

[Experimenter 3] 10:58:15
Okay.

[Experimenter 3] 10:58:17
So moving to this step, what are some of the factors that would influence your ability to succeed in

[Experimenter 3] 10:58:24
looking for and identifying indicators of flags slash common bugs.

[Participant 1] 10:58:28
Yeah, I think a big part of that is your uh

[Participant 1] 10:58:33
your decompilation

[Participant 1] 10:58:36
Not success necessarily but you're

[Participant 1] 10:58:40
readability, I guess, of decompilation. So that doesn't like, you know, there's a big difference between in step C, the code actually decompiling successfully. And in step D being able

[Participant 1] 10:58:51
to read it. And that really impacts D and E. Like I think D and E are, you know.

[Participant 1] 10:58:56
can be thought of a lot of the

[Participant 1] 10:58:59
like very similar um so

[Participant 1] 10:59:01
A lot of these will be the case for both. Got it. But if the decompilation is unreadable, that makes

[Participant 1] 10:59:08
D and E a lot more difficult.

[Experimenter 3] 10:59:10
Okay, so would you say that this kind of sits between like

[Experimenter 3] 10:59:16
these as well as upload to Kidra and this tab

[Participant 1] 10:59:20
Yeah, I think so. 

[Experimenter 3] 10:59:22
Okay, cool.

[Experimenter 3] 10:59:33
And just have this as a mediator, basically.

[Experimenter 3] 10:59:41
And would this be true of disassemblers, emulation, VMs, and other decompilers? 

[Participant 1] 10:59:45
Other decompilers, certainly. Emulation or VMs, you're not going to really be reading much, so yeah.

[Experimenter 3] 10:59:53
Got it. Okay.

[Experimenter 3] 11:00:01
All right. Awesome.

[Experimenter 3] 11:00:07
So this is a big enabler or factor that affects that.

[Experimenter 3] 11:00:12
What issues affect the readability of the decompilation aside from these prior issues that we've mentioned?

[Participant 1] 11:00:28
And then…

[Participant 1] 11:00:30
Yeah, I think that's a big one.

[Experimenter 3] 11:00:32
Okay.

[Experimenter 3] 11:00:34
So code obfuscation would have a negative naturally um

[Participant 1] 11:00:40
And then symbols is the other

[Participant 1] 11:00:43
Major one. Debug symbols, like debug.

[Participant 1] 11:00:48
That both means like, you know, debug strings in the code that say like, hey, like, you know.

[Participant 1] 11:00:55
Error, file not found like that that makes your code a lot more readable because then you know, hey, a file was being opened here. And then you can also have debug symbols in the case of

[Participant 1] 11:01:02
you know, there are

[Participant 1] 11:01:06
I guess ways to compile code, like think about like c

[Participant 1] 11:01:11
with like C, you can use Tech G and that'll have, you know, all of your

[Participant 1] 11:01:16
actual

[Participant 1] 11:01:18
symbols.

[Experimenter 3] 11:01:19
Okay, so it'd be debug symbols for errors and then debug symbols for compilation. 

[Participant 1] 11:01:23
Yeah.

[Experimenter 3] 11:01:27
Okay. 

[Participant 1] 11:01:28
And I think instead of errors, I would say like, or I would say debug strings there for error status of symbols.

[Experimenter 3] 11:01:35
And is it errors or is it really logs? 

[Participant 1] 11:01:38
It's logs, it's errors. It's like, yeah.

[Experimenter 3] 11:01:43
Okay. 

[Participant 1] 11:01:44
And then I think decompilation is readable can also…

[Experimenter 3] 11:01:47
Would you say these are positive

[Participant 1] 11:01:51
Those are positive. Yes.

[Participant 1] 11:01:53
Yeah.

[Experimenter 3] 11:01:56
Yeah. Great.

[Experimenter 3] 11:02:02
And what was that you were adding? Sorry. 

[Participant 1] 11:02:04
Oh, I was saying that like, I think really your decompilation is readable can also point directly to E as well.

[Experimenter 3] 11:02:10
Oh, great. Yeah.

[Experimenter 3] 11:02:11
Alrighty.

[Experimenter 3] 11:02:13
Are there other factors that may affect your success in looking for common bug classes or indicators of the flag?

[Experimenter 3] 11:02:22
And you can think of specific examples here if it's helpful.

[Participant 1] 11:02:27
I think…

[Participant 1] 11:02:28
The decompilation readability is a big one.

[Participant 1] 11:02:33
In CTFs, you don't really fuzz anything. There's just not time.

[Participant 1] 11:02:39
Usually.

[Participant 1] 11:02:41
So I think the

[Participant 1] 11:02:44
Yeah, I think the readability of decompilation is your main

[Participant 1] 11:02:50
point there.

[Experimenter 3] 11:02:54
I'm wondering if we could even just add that essentially lack of time.

[Experimenter 3] 11:02:58
And that would negatively affect your ability to look for

[Participant 1] 11:03:03
Yes.

[Experimenter 3] 11:03:08
Okay.

[Experimenter 3] 11:03:11
Moving to this next step here, understanding how the user input leads to vulnerability.

[Experimenter 3] 11:03:17
Are there specific factors underlying that that would impact the success of it?

[Experimenter 3] 11:03:21
Other than the ones that we have already kind of put in here. 

[Participant 1] 11:03:23
Yeah, I think so. I think for that one, especially the um

[Participant 1] 11:03:27
your ability to run the program back when we were talking about like emulation

[Participant 1] 11:03:32
that can negatively impact it.

[Participant 1] 11:03:36
If you can't so like

[Participant 1] 11:03:38
Like if you have the ability, that's a positive impact. If you don't, that's a negative.

[Experimenter 3] 11:03:45
Okay.

[Participant 1] 11:03:47
And then…

[Participant 1] 11:03:49
Yeah. And then I also think

[Participant 1] 11:03:52
Understanding like understanding

[Participant 1] 11:03:53
the ability to debug the program.

[Participant 1] 11:03:56
run it in GDB, run like you know

[Participant 1] 11:04:02
use a debugger.

[Participant 1] 11:04:08
And get meaningful information out of it.

[Participant 1] 11:04:12
And that means, you know, register contexts. That means, you know, understanding the

[Participant 1] 11:04:18
control flow of the program, you know, being able to set a breakpoint and saying, hey, okay, I see my

[Participant 1] 11:04:22
user input has moved from

[Participant 1] 11:04:26
one point to the other. 

[Experimenter 3] 11:04:28
You mentioned register context and control flow 

[Participant 1] 11:04:29
yeah

[Experimenter 3] 11:04:31
Okay. Are there other examples here? Are those just two? 

[Participant 1] 11:04:36
Those are two that come to mind. There are certainly more.

[Experimenter 3] 11:04:39
Okay. Got it.

[Experimenter 3] 11:04:43
This, would you say that the ability to run the program is first necessary before you would even be able to use the debugger?

[Participant 1] 11:04:48
Yes.

[Experimenter 3] 11:04:49
Right.

[Experimenter 3] 11:04:52
And then this affects how, basically back to the main step there of understanding how user input leads to the vulnerability.

[Participant 1] 11:04:59
yep

[Experimenter 3] 11:05:00
Got it. Okay.

[Experimenter 3] 11:05:03
Are there other issues or details that may affect these two abilities other than

[Experimenter 3] 11:05:11
the architecture supporting the locally running.

[Participant 1] 11:05:15
I think the uh

[Participant 1] 11:05:16
use of anti-debugger techniques, which you do see sometimes.

[Participant 1] 11:05:24
So that means…

[Participant 1] 11:05:26
you know in windows there's like a function you can even just call that says like is debugger present

[Participant 1] 11:05:33
And then like exiting from debuggers if it is

[Participant 1] 11:05:37
There's other ways to check if you're running in a VM, for instance. A lot of these are malware techniques, so you don't see them as often in CTFs, but you can.

[Participant 1] 11:05:45
And in the same

[Participant 1] 11:05:47
vein, I think, yeah, we already talked about decompilation being readable

[Participant 1] 11:05:53
Really, it's malware techniques, not. 

[Experimenter 3] 11:05:56
Oh, okay, got it.

[Experimenter 3] 11:05:59
Okay, so these are

[Experimenter 3] 11:06:00
Can you clarify my understanding here? Malware techniques uh

[Experimenter 3] 11:06:06
would… Would…

[Experimenter 3] 11:06:09
If they, sorry, go ahead. 

[Participant 1] 11:06:12
A lot of times, so when you're writing malware, you don't want

[Participant 1] 11:06:16
a um you know

[Participant 1] 11:06:17
blue team defender to be able to easily reverse engineer your malware, tell what it's doing, what server it's reaching out to. So a lot of times you'll use a lot of

[Participant 1] 11:06:27
those like code obfuscation techniques we mentioned, but also a lot of anti-debugging techniques like

[Participant 1] 11:06:32
you know, checking if debuggers are present, making sure that you can't like P trace binaries like that

[Participant 1] 11:06:39
So those are like more of the techniques than the actual like

[Participant 1] 11:06:43
Yeah.

[Experimenter 3] 11:06:44
Got it. This is something then that potentially an attacker would use as opposed to a defense system.

[Participant 1] 11:06:49
Yes, this is an attacker, yeah. 

[Experimenter 3] 11:06:52
Got it. Okay.

[Experimenter 3] 11:07:01
Okay.

[Experimenter 3] 11:07:04
I'll add that that is then in the offensive context.

[Experimenter 3] 11:07:11
Okay.

[Experimenter 3] 11:07:14
Any other issues or details come to mind that might affect the ability to either run the program or to use the debugger

[Experimenter 3] 11:07:19
debug the program to get meaningful information. 

[Participant 1] 11:07:22
I think those are the main ones. 

[Experimenter 3] 11:07:24
This code obfuscation come into play here as well?

[Participant 1] 11:07:27
Not as much because the program has to run at the end of the day. That's more for debugging though. I would say code obfuscation.

[Participant 1] 11:07:34
negatively impacts your ability to use a debugger.

[Participant 1] 11:07:36
If you wanted to attach those two.

[Participant 1] 11:07:40
Because a lot of times that means that you

[Participant 1] 11:07:45
you know, if you can't read the code, you can't debug the code type of thing. 

[Experimenter 3] 11:07:49
Sure, sure. Yeah.

[Experimenter 3] 11:07:51
All right, then we get over to exercising the proof of concept locally.

[Experimenter 3] 11:07:57
Other than looking for bug classes and finding them successfully, as well as understanding how the input leads to vulnerability.

[Experimenter 3] 11:08:05
What are some other factors that might influence your success in exercising proof of concept locally? 

[Participant 1] 11:08:11
I think the...Again, you have the same problem with like ability to run the program.

[Participant 1] 11:08:16
like if you can't run it, you can't find the bug locally.

[Participant 1] 11:08:22
So, and then other than that, I think it's mostly just like your internal success rather than anything external that's going to

[Participant 1] 11:08:30
So it's like, if you found a bug that doesn't actually exist.

[Participant 1] 11:08:33
you're not going to be able to exercise it locally.

[Participant 1] 11:08:36
But I think the ability to use a debugger is also

[Participant 1] 11:08:40
stronger one. 

[Experimenter 3] 11:08:41
So is that back to maybe your ideas about the challenge

[Participant 1] 11:08:45
Yeah, I think it can be. Okay. Okay.

[Experimenter 3] 11:08:51
If you successfully confirm ideas about the challenge, then you have

[Experimenter 3] 11:08:54
that positively influences your ability to do this.

[Participant 1] 11:08:58
And then, yeah, I would say successful being able to use a debugger.

[Participant 1] 11:09:02
is positive as well. 

[Experimenter 3] 11:09:07
Got it. Okay.

[Experimenter 3] 11:09:10
Are there specific issues or details that could

[Experimenter 3] 11:09:14
thinking in the negative context, cause failure and exalting your proof of concept that we haven't mentioned.

[Participant 1] 11:09:22
I think mitigations is really where these come into play so like

[Participant 1] 11:09:28
By that, I mean ASLR, data execution prevention like

[Participant 1] 11:09:34
common sort of like stat canaries as well, like common

[Participant 1] 11:09:38
Common mitigations.

[Participant 1] 11:09:40
But…

[Experimenter 3] 11:09:42
defensive mitigations. 

[Participant 1] 11:09:44
Yeah, defensive mitigations. Got it.

[Experimenter 3] 11:09:53
that affects your ability to exercise the proof of concept locally. 

[Participant 1] 11:09:58
Yep.

[Experimenter 3] 11:10:00
Okay. If you see a defensive mitigation, what is your um

[Experimenter 3] 11:10:05
how does your course of action change?

[Participant 1] 11:10:09
you basically need to go back to understanding the user input and understanding how to

[Participant 1] 11:10:12
get around that mitigation, like bypass the mitigation.

[Participant 1] 11:10:16
So a lot of times that's when you start going back into Gaer and saying, okay, so now that we know there's a stack canary here and we can't just do a normal buffer overflow, what can we do next? And a lot of times that also means

[Participant 1] 11:10:29
building the exploit primitives uh

[Participant 1] 11:10:31
In order to get around that mitigation.

[Experimenter 3] 11:10:36
I see. So let me correct this to say um

[Experimenter 3] 11:10:41
discovery of 

[Participant 1] 11:10:42
yeah

[Experimenter 3] 11:10:44
defensive mitigations will negatively affect your ability to do that

[Experimenter 3] 11:10:47
it will improve your understanding of how the user input

[Experimenter 3] 11:10:51
leads to vulnerability. So that's a positive.

[Experimenter 3] 11:10:56
It also then to bring back to

[Experimenter 3] 11:11:00
here, right?

[Participant 1] 11:11:00
Yeah

[Experimenter 3] 11:11:01
That's positive.

[Experimenter 3] 11:11:06
So in short, if you discover this.

[Experimenter 3] 11:11:08
you step back and then work through how to

[Experimenter 3] 11:11:14
How to bypass. How to bypass these mitigations.

[Participant 1] 11:11:16
Yep. 

[Experimenter 3] 11:11:16
Okay.

[Participant 1] 11:11:18
And a lot of times that also, I would say, goes to build exploit primitives

[Experimenter 3] 11:11:27
I see. 

[Participant 1] 11:11:28
Yeah. So I think that, yeah.

[Experimenter 3] 11:11:30
And that's a negative relationship, discovery of defensive mitigations will negatively affect that.

[Participant 1] 11:11:33
Yep

[Experimenter 3] 11:11:35
Okay.

[Experimenter 3] 11:11:38
discovering them would positively lead to successfully bypassing them naturally.

[Participant 1] 11:11:43
Yep

[Experimenter 3] 11:11:46
Okay. Which then…

[Experimenter 3] 11:11:49
will positively lead to

[Participant 1] 11:11:51
Exercising and talk.

[Participant 1] 11:11:53
And building the exploit for this.

[Experimenter 3] 11:11:55
All right.

[Experimenter 3] 11:11:59
And to confirm that's intended to be a comma there to exploit

[Participant 1] 11:12:06
No, that should not be a comma.

[Experimenter 3] 11:12:09
Yep. Got it. Okay.

[Experimenter 3] 11:12:11
Are there other factors that lead to the success of building the exploit primitives?

[Participant 1] 11:12:18
Other than the ones we've already covered, like using a debugger and the defensive mitigations, I think those are the two main ones. Okay.

[Participant 1] 11:12:27
So.

[Experimenter 3] 11:12:30
So ability to use debugger has a very yeah

[Participant 1] 11:12:33
And then the defense of mitigations is negative, like we already saw.

[Participant 1] 11:12:38
Yep. And then…

[Participant 1] 11:12:40
Same with developing the local exploit, really. All of these pretty much

[Participant 1] 11:12:45
Because these are so cyclical, they've reliant.

[Experimenter 3] 11:12:52
Do any of these other ones reach back to

[Experimenter 3] 11:12:56
running locally slash uploaded to Ghidra or is that all sort of through the discovery of mitigations?

[Participant 1] 11:13:02
It's usually through the discovery of mitigations, but it can be without it. So I would say that yeah like uh

[Participant 1] 11:13:07
I don't know. I think I would actually define it more as going back to like looking for common bug classes. Like usually you don't have to like re-upload to Ghidra. Usually it's re-looking in Ghidra. 

[Experimenter 3] 11:13:17
Got it.

[Experimenter 3] 11:13:18
Got it. Okay. 

[Participant 1] 11:13:18
But, Yeah.

[Participant 1] 11:13:20
And then…

[Experimenter 3] 11:13:23
Okay. 

[Participant 1] 11:13:24
Yeah. Same with the remote

[Participant 1] 11:13:26
I would say the unique thing about the remote exploit on the bottom there is that

[Participant 1] 11:13:31
You also may have to go all the way back to like connect to server and download

[Participant 1] 11:13:37
File.

[Experimenter 3] 11:13:38
Oh, interesting. Okay. 

[Participant 1] 11:13:41
Yeah.

[Participant 1] 11:13:41
Because that can be where you're like, oh, wait, I didn't connect to this correctly like that

[Experimenter 3] 11:13:48
So you would do that if you discovered

[Experimenter 3] 11:13:53
some some

[Experimenter 3] 11:13:54
difference between your local context and the remote context? 

[Participant 1] 11:13:57
Yeah, you would do that then. You would also do that just when you

[Participant 1] 11:14:04
Like…

[Participant 1] 11:14:05
if there is just an issue connecting to the remote in general, you can have that as well.

[Experimenter 3] 11:14:13
Got it.

[Experimenter 3] 11:14:15
That brings you back to here. 

[Participant 1] 11:14:18
Yeah. 

[Experimenter 3] 11:14:19
Okay.

[Experimenter 3] 11:14:21
Okay.

[Experimenter 3] 11:14:24
Are there other factors that influence your success in developing the local exploit?

[Participant 1] 11:14:30
I think it's mostly based on the primitives the uh

[Participant 1] 11:14:35
like the number of primitives available

[Participant 1] 11:14:38
And I don't

[Participant 1] 11:14:40
I think you could add something here that talks about like support of

[Participant 1] 11:14:46
primitive discovery tools.

[Participant 1] 11:14:50
Yeah, so like sufficient number of primitives available and that's going to go with builds

[Participant 1] 11:14:55
And as well as like local exploit.

[Participant 1] 11:15:00
But then there's also the concept of like

[Participant 1] 11:15:04
how usable are primitive discovery tools in

[Participant 1] 11:15:10
This case?

[Participant 1] 11:15:11
So by that, I mean there's tools like Ropper, there's tools like

[Participant 1] 11:15:17
You can also just use your grep, but like, you know.

[Participant 1] 11:15:22
How easy is it to actually discover

[Participant 1] 11:15:26
Romper, R-O-P-P-E-R.

[Experimenter 3] 11:15:28
Thank you.

[Participant 1] 11:15:29
No, you're fine.

[Participant 1] 11:15:32
Yeah, so I think that's how easy it is to discover primitives um

[Participant 1] 11:15:38
And if that is easier, then you have a better time.

[Participant 1] 11:15:42
Or you're more likely to succeed.

[Experimenter 3] 11:15:52
Okay.

[Experimenter 3] 11:15:55
And this essentially improves your ability to

[Experimenter 3] 11:15:59
Discover. 

[Participant 1] 11:16:00
Yeah.

[Experimenter 3] 11:16:07
And it's positive.

[Experimenter 3] 11:16:09
this and this.

[Experimenter 3] 11:16:11
Naturally, positive. Okay.

[Experimenter 3] 11:16:15
Are there issues or details that may negatively affect your ability to discover primitives aside from the availability of tools?

[Participant 1] 11:16:23
I think the architecture, like going back to architecture and OS,

[Participant 1] 11:16:28
not necessarily the support in uploading to decompiler, but like different architectures

[Participant 1] 11:16:34
are either more or less difficult to find primitives in so

[Participant 1] 11:16:38
You can think of it as like, okay, well, if you're in ARM, you need to

[Participant 1] 11:16:42
now make sure that like you're executing in the correct mode. You can't just assume that you can

[Participant 1] 11:16:48
or you can run every single primitive because the

[Participant 1] 11:16:51
you know you might you might be in thumb mode right now and you can't just

[Participant 1] 11:16:57
switch back and forth without an instruction to do that. So I think architecture.

[Participant 1] 11:17:02
PowerPC is also really difficult for primitives.

[Experimenter 3] 11:17:05 
So are you thinking ARM and PowerPC in particular?

[Participant 1] 11:17:09
No, there's a lot more than that. There's many.

[Experimenter 3] 11:17:12
Okay.

[Experimenter 3] 11:17:14
Does that do the…

[Experimenter 3] 11:17:15
Does the architecture in those cases also affect basically the availability of tools?

[Participant 1] 11:17:18
Yes.

[Experimenter 3] 11:17:19
Right. Okay.

[Experimenter 3] 11:17:22
Okay.

[Experimenter 3] 11:17:25
Okay.

[Participant 1] 11:17:27
Yeah, and then I think that's really most of it for

[Participant 1] 11:17:32
these. I think the remote exploit is basically the like once you've developed a local exploit and it works successfully, that means that there is something wrong between your

[Participant 1] 11:17:43
remote and local. I think that's really the only issue that can

[Participant 1] 11:17:48
happen.

[Experimenter 3] 11:17:49
So if you do encounter an issue, yeah.

[Participant 1] 11:17:52
You got to go back. Got it.

[Experimenter 3] 11:17:55
you go back to

[Experimenter 3] 11:17:57
this step? Are there other steps you may go back to here?

[Participant 1] 11:18:00
You might go back to really all of them.

[Experimenter 3] 11:18:03
Okay. But yeah. Okay.

[Experimenter 3] 11:18:05
Sure.

[Participant 1] 11:18:09
And then, yeah, get the flag.

[Experimenter 3] 11:18:11
Okay, so…

[Experimenter 3] 11:18:13
We've gotten, I think, some of the factors and details documented here.

[Experimenter 3] 11:18:18
Now let

[Experimenter 3] 11:18:19
walk through each step kind of quickly and imagine uh

[Experimenter 3] 11:18:25
that some sort of unexpected surprise occurs.

[Experimenter 3] 11:18:30
So what would be an example of an unexpected surprise that might affect downloading the files or connecting to the server?

[Participant 1] 11:18:35
I think getting like a fail to connect error like

[Experimenter 3] 11:18:39
Mm-hmm.

[Experimenter 3] 11:18:53
What might be an example of an unexpected surprise at the step of attempting to run locally or upload to Kidra?

[Participant 1] 11:18:59
I think that's when you like the tool and system doesn't support the approach is really the

[Participant 1] 11:19:07
Yeah, I think that is your unexpected surprise there. 

[Experimenter 3] 11:19:10
Okay. Are there any others that come to mind?

[Experimenter 3] 11:19:13
That would be the one. 

[Participant 1] 11:19:14
No, that's really the one.

[Experimenter 3] 11:19:15
Okay.

[Experimenter 3] 11:19:18
From there, let's say that the decompilation is readable and you're looking for common bug classes or indicators of the flag.

[Experimenter 3] 11:19:24
what might be sort of an unexpected surprise at this step that might mitigate your progress?

[Participant 1] 11:19:31
As long as the decompilation is readable.

[Participant 1] 11:19:35
That's the big one, I think, and the ability to successfully decompile or decompile at all like the

[Participant 1] 11:19:42
that.

[Participant 1] 11:19:44
Yeah, I think those are the main ones there.

[Experimenter 3] 11:19:49
Okay.

[Experimenter 3] 11:19:52
Next, understanding how the user input leads to vulnerability.

[Experimenter 3] 11:19:56
Are there any particular unexpected tricks or surprises that you might encounter at this step that would mitigate your progress?

[Participant 1] 11:20:02
I think the like

[Participant 1] 11:20:04
decompilation being readable along with the ability to run the program.

[Participant 1] 11:20:09
Those are the two main ones that you see.

[Experimenter 3] 11:20:13
Are there unexpected facets that could arise affecting the readability of the decompilation?

[Participant 1] 11:20:18
I think like uh

[Participant 1] 11:20:20
a different code obfuscation techniques can arise and not be like

[Participant 1] 11:20:24
obvious at the beginning. So you can have things like

[Participant 1] 11:20:29
you know self-unpacking binary type of

[Participant 1] 11:20:33
type of deal. So, you know, the first few functions look fine but

[Participant 1] 11:20:38
the you know once you get like three or four layers in, you're like, wow, this doesn't make any sense. And it turns out that like you

[Participant 1] 11:20:45
you're unpacking yourself or you're intentionally

[Participant 1] 11:20:50
using yeah like code obfuscation techniques. 

[Experimenter 3] 11:20:53
This is basically be like an unexpected form of code obfuscation.

[Participant 1] 11:20:57
Yeah, that would be a really unexpected one.

[Experimenter 3] 11:21:00
Mm-hmm.

[Participant 1] 11:21:02
I've also seen in instances where you switch architectures midway through the program.

[Participant 1] 11:21:08
Which is…

[Participant 1] 11:21:10
insane.

[Participant 1] 11:21:12
But yeah, I also think like there are some really really weird

[Participant 1] 11:21:18
things that you could have there.

[Experimenter 3] 11:21:22
Okay, switching architecture, that would be…

[Experimenter 3] 11:21:30
during the CTF? 

[Participant 1] 11:21:32
Not during the CTF, like during execution.

[Experimenter 3] 11:21:34
Oh, okay. Okay.

[Experimenter 3] 11:21:37
Like, all right. At what point might you discover that?

[Participant 1] 11:21:41
That usually happens when you're understanding how the user input leads to a vault. Like, can we do a vulnerability? And specifically the ability to run the program in emulation. That's when you're emulation.

[Participant 1] 11:21:52
really um

[Participant 1] 11:21:56
fail.

[Experimenter 3] 11:21:58
Got it.

[Experimenter 3] 11:22:00
So this would positively affect this step because it's where you would discover it.

[Participant 1] 11:22:04
Yep

[Experimenter 3] 11:22:04
But this would negatively affect your ability to run emulation. 

[Participant 1] 11:22:08
Yes

[Experimenter 3] 11:22:09
What might some mitigation steps be if you do this or if you discover this time?

[Participant 1] 11:22:14
A lot of that is statically analyzing and then emulating multiple parts of the binary with different emulation.

[Participant 1] 11:22:23
techniques so like you would you would basically say, okay, well, we know this part of the binary

[Participant 1] 11:22:28
is running an arm and this part is running

[Participant 1] 11:22:32
in power pc or something

[Participant 1] 11:22:35
Let's break them out. You can see some really great stuff in CTS.

[Experimenter 3] 11:22:39
Gotcha. Okay.

[Experimenter 3] 11:22:44
um

[Experimenter 3] 11:22:46
what might be an unexpected…

[Experimenter 3] 11:22:50
issue um or issue

[Experimenter 3] 11:22:52
blocker to your ability to use the debugger or debug the program to get meaningful information.

[Experimenter 3] 11:22:56
Other than anti-debugger techniques, are there other things?

[Participant 1] 11:22:59
Just not being able to run it in general, but I think we have that as well.

[Participant 1] 11:23:05
And then code obfuscation as well, which I know we already touched on that too. 

[Experimenter 3] 11:23:09
Yep. 

[Participant 1] 11:23:09
Yeah, so I think those are great.

[Experimenter 3] 11:23:11
Okay. Are there any potential unexpected surprises that you might encounter that would

[Experimenter 3] 11:23:16
affect your progress at exercising the POC locally?

[Participant 1] 11:23:19
That's usually the defensive mitigations. Like that's definitely the big one.

[Participant 1] 11:23:25
And then the ability to run the program again.

[Participant 1] 11:23:28
will impact that.

[Experimenter 3] 11:23:30
Yeah, I believe we have that connected. Yes.

[Experimenter 3] 11:23:33
Okay.

[Experimenter 3] 11:23:36
during building exploit primitives any

[Experimenter 3] 11:23:40
unexpected issues that might arise there.

[Participant 1] 11:23:48
I don't think.

[Participant 1] 11:23:50
like none that we haven't already mentioned, like the number of primitives available. Yeah, I think those are the main ones. 

[Experimenter 3] 11:23:57
Got it. Okay.

[Experimenter 3] 11:23:59
So let's see. Yeah, building the so as this currently stands, building the exploit primitives enables

[Experimenter 3] 11:24:06
understanding that there's a sufficient number of primitives available.

[Experimenter 3] 11:24:13
or confirming, maybe.

[Participant 1] 11:24:15
Yeah.

[Experimenter 3] 11:24:17
Is that the case or is this the result of a different step that enables the success of this?

[Participant 1] 11:24:22
I think that's the case. Because once you start building them, that's when you're looking for the number of primitives you have. Like it's, yeah.

[Experimenter 3] 11:24:29
Okay.

[Experimenter 3] 11:24:31
Then we get to developing the local exploit. What might be an unexpected surprise or issue that would affect you at that point?

[Participant 1] 11:24:41
Yeah, I think, you know, availability of primitives, I think you've already proven that the proof of concept exists. So it is a lot of

[Participant 1] 11:24:49
Ability to chain together primitives, I guess, would be a

[Participant 1] 11:24:53
Another one. So, you know, you might have some really nice primitives, but how do you get from one to the other?

[Experimenter 3] 11:25:02
Mm-hmm.

[Experimenter 3] 11:25:07
Right.

[Experimenter 3] 11:25:13
And that, let's see.

[Experimenter 3] 11:25:15
is probably related to confirming a sufficient number are available that enables you to build

[Experimenter 3] 11:25:20
that gives you the ability to chain them?

[Participant 1] 11:25:22
Yeah, I think so. 

[Experimenter 3] 11:25:24
Okay.

[Participant 1] 11:25:24
I would say those are like related like they go hand in hand

[Experimenter 3] 11:25:31
Yeah, sure. That makes sense.

[Experimenter 3] 11:25:34
Okay.

[Experimenter 3] 11:25:36
How about in the course of developing the remote exploit once you have developed a local exploit? So this issue between local and remote context?

[Experimenter 3] 11:25:44
Are there unexpected surprises that arise at that?

[Experimenter 3] 11:25:47
of that or that cause these issues to emerge?

[Participant 1] 11:25:51
Nothing like yes

[Participant 1] 11:25:53
A lot of that is like your local setup is wrong. Like at the end of the day, that's what that is, right? Like you set something up incorrectly. So it's your prior assumptions being wrong.

[Experimenter 3] 11:26:08
Right.

[Participant 1] 11:26:10
And that really causes that the issue between the local and the remote.

[Experimenter 3] 11:26:16
Yeah, and this stymies remote progress

[Experimenter 3] 11:26:19
And this also

[Participant 1] 11:26:22
uh…

[Participant 1] 11:26:24
I was going to say the other thing you can see a lot of is

[Participant 1] 11:26:27
assumptions about static versus dynamic

[Participant 1] 11:26:33
variables, I guess you could say. So you might assume

[Participant 1] 11:26:37
that you know hey this

[Participant 1] 11:26:40
variable doesn't change between runs when really it does just because of how you've configured.

[Participant 1] 11:26:45
So that really leads into like your local setup being wrong but

[Experimenter 3] 11:26:51
Mm-hmm.

[Experimenter 3] 11:26:54
Okay, that's like an instance of how your local setup could be wrong.

[Participant 1] 11:26:57
Yeah. 

[Experimenter 3] 11:27:00
Okay. Are there other common instances of how your local setup might be wrong?

[Participant 1] 11:27:04
Wrong versions of

[Participant 1] 11:27:07
binaries, whether that's like ones that have been given to you or ones that

[Experimenter 3] 11:27:23
Okay. And would you say that

[Experimenter 3] 11:27:25
confirming your ideas about the challenge

[Experimenter 3] 11:27:29
would reduce the probability that your local setup is wrong.

[Participant 1] 11:27:33
Yes.

[Experimenter 3] 11:27:35
just as kind of a meta knowledge point.

[Participant 1] 11:27:38
Yep. 

[Experimenter 3] 11:27:42
Okay. So things like identifying the common bug classes and indicators of the flag, understanding how the input leads to the vulnerability that improves your understanding of the challenge, which then could improve your local setup.

[Experimenter 3] 11:27:53
Or sorry,

[Participant 1] 11:27:54
yeah, it would.

[Experimenter 3] 11:27:55
reduce the errors there. Okay.

[Experimenter 3] 11:27:58
At the last step of getting the flag, are there unexpected surprises that emerge there?

[Participant 1] 11:28:02
Sometimes you can only leak certain amounts of characters, and I think that can be unexpected. Like if you think, okay, well, I can get back, you know, 30 characters from the server.

[Participant 1] 11:28:12
But that's not enough.

[Experimenter 3] 11:28:27
Okay. 

[Participant 1] 11:28:28
And that would negatively

[Experimenter 3] 11:28:31
Yeah, got it.

[Experimenter 3] 11:28:33
If that occurs, what do you need to do?

[Participant 1] 11:28:37
you go back to building your remote exploit.

[Participant 1] 11:28:41
And saying, okay, I know I can only

[Participant 1] 11:28:47
X number of characters how do i

[Experimenter 3] 11:28:51
So that improves your development of your remote exploit.

[Participant 1] 11:28:54
Yeah. 

[Experimenter 3] 11:28:55
Okay. Okay.

[Experimenter 3] 11:28:58
So quickly, working through the steps again, this is the last time we'll iterate through them.

[Experimenter 3] 11:29:05
Are there any unexpected distractions or disruptions?

[Experimenter 3] 11:29:09
Things that might distract you while you're downloading files or connect to the server or lead to you wasting time.

[Participant 1] 11:29:17
I don't think so there, really. Okay.

[Experimenter 3] 11:29:21
At this step, are there potential distractions or

[Participant 1] 11:29:25
Yeah, if you change your file headers, so you can run like file or check sec on a binary, it will show you what

[Participant 1] 11:29:32
what type what type of file it is. But if your file headers are incorrect

[Participant 1] 11:29:37
uh or like you know

[Participant 1] 11:29:39
incorrect or misleading, I guess.

[Participant 1] 11:29:42
I would say misleading.

[Participant 1] 11:29:45
Leading to incorrect assumptions like that.

[Participant 1] 11:29:49
That will definitely let you spend time there.

[Experimenter 3] 11:29:58
Okay.

[Experimenter 3] 11:30:07
At the Looking for Common Bug Class classes um

[Experimenter 3] 11:30:11
and indicators of the flag, are there potential distractions at that point that might lead to wasting time?

[Participant 1] 11:30:16
The code obfuscation and readability of decompilation is kind of that distraction.

[[Participant 1] 11:30:22
Yeah, I think that's the main one for that one as well as the understanding how user input.

[Participant 1] 11:30:32
can lead to yeah

[Experimenter 3] 11:30:34
lead to the vulnerability.

[Participant 1] 11:30:36
Yep.

[Experimenter 3] 11:30:40
Okay. Are there potentially other distractions or disruptions that might arise looking at some of these other issues down here?

[Participant 1] 11:30:50
I think…

[Participant 1] 11:30:52
Anything that…

[Participant 1] 11:30:54
any information you're getting out of the binary that is

[Participant 1] 11:31:00
you know misleading or incorrect once again.

[Participant 1] 11:31:04
So like, yeah, there's like misleading file headers

[Participant 1] 11:31:08
But also, you know.

[Participant 1] 11:31:10
I've certainly seen it that like some binaries can decompile happily in multiple architectures. Like you have a

[Participant 1] 11:31:18
Oh gosh, I don't know what those are called.

[Participant 1] 11:31:20
Polyglot type of situation.

[Participant 1] 11:31:27
Yeah. So I think that can that can really distract

[Participant 1] 11:31:31
From your ability to

[Participant 1] 11:31:32
use the debugger.

[Participant 1] 11:31:36
And also from like readability in general but

[Experimenter 3] 11:31:38
Got it. Okay.

[Experimenter 3] 11:31:41
from decompilation being readable or another 

[Participant 1] 11:31:44
Yep

[Experimenter 3] 11:31:45
another okay

[Experimenter 3] 11:31:46
Got it. Great.

[Experimenter 3] 11:31:50
Last piece over here, exercising the epoch locally. Are there sometimes distractions or

[Experimenter 3] 11:31:57
factors that lead you lead you to waste time?

[Participant 1] 11:32:01
I think the biggest one there is like the

[Participant 1] 11:32:04
vagueness of instructions around execution that

[Participant 1] 11:32:09
Uh, uh, uh.

[Participant 1] 11:32:12
So that kind of goes back to your like understanding of the challenges like if

[Participant 1] 11:32:16
you know if you're not provided with certain

[Participant 1] 11:32:19
files that you think you need or like there's a lot of setup in place like that that can really

[Participant 1] 11:32:24
be a distraction.

[Participant 1] 11:32:25
And that's like, it's a necessary part but it's

[Participant 1] 11:32:29
it wastes a lot of time.

[Experimenter 3] 11:32:34
So basically some missing understanding about the challenge

[Participant 1] 11:32:38
Yeah

[Experimenter 3] 11:32:45
That needs to be a little more specific here.

[Experimenter 3] 11:32:51
And that will negatively affect your ability to confirm your ideas and will also

[Experimenter 3] 11:32:58
potentially lead to vague execution instructions. 

[Participant 1] 11:33:01
Yep.

[Experimenter 3] 11:33:01
Okay.

[Experimenter 3] 11:33:05
Same question for building exploit primitives. Are there potential distractions here or

[Experimenter 3] 11:33:10
time wasters.

[Participant 1] 11:33:12
Yeah. And I think it's those like common tools um

[Participant 1] 11:33:16
either failing or being intentionally misled. So you can you know

[Participant 1] 11:33:22
you could intentionally say

[Participant 1] 11:33:26
That's profitable.

[Participant 1] 11:33:28
and stuff.

[Experimenter 3] 11:33:30
Okay.

[Experimenter 3] 11:33:45
Would that be part and parcel with the architecture making the discovery of primitives difficult or it's a separate issue, really?

[Participant 1] 11:33:50
Yes, I would say it's

[Participant 1] 11:33:51
It's a separate issue, but it's related.

[Experimenter 3] 11:33:55
Okay. Does the architecture making primitives difficult inform this or does

[Experimenter 3] 11:34:00
Yeah, would you say that's the case?

[Participant 1] 11:34:03
Yeah, I think so. Okay.

[Experimenter 3] 11:34:06
Great.

[Experimenter 3] 11:34:08
down to develop local exploit and develop remote exploit.

[Experimenter 3] 11:34:11
unexpected distractions or time wasters or anything like that.

[Participant 1] 11:34:18
Nothing super major comes to mind for those ones that aren't your internal

[Participant 1] 11:34:23
misunderstanding again. I think misunderstanding about the challenge can really

[Participant 1] 11:34:28
drive those to take much longer than they should. 

[Experimenter 3] 11:34:31
Got it.

[Experimenter 3] 11:34:34
Yeah. Okay. I recognize we're now for just

[Experimenter 3] 11:34:38
past four minutes over. I apologize for that.

[Experimenter 3] 11:34:41
Are there any factors, issues, details that are very influential in progress that are missing from this diagram or that come to mind that you

[Experimenter 3] 11:34:50
you'd want to note that aren't here.

[Participant 1] 11:34:53
I don't think so. I think this is all.

[Participant 1] 11:34:56
Or at least a majority of them, yeah.

[Experimenter 3] 11:34:58
All right. Well, great.

[Experimenter 3] 11:35:02
Then that completes the

[Experimenter 3] 11:35:04
the FCM

[Experimenter 3] 11:35:07
exercise and we'll save this diagram.