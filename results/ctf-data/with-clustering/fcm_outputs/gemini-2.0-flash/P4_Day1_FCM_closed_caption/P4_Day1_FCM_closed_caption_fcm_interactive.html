
<!DOCTYPE html>
<html>
<head>
    <title>Hierarchical FCM Visualization (Unconnected nodes removed)</title>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 0; 
            padding: 20px;
            background: #f5f5f5;
        }
        
        #network { 
            width: 100%; 
            height: 600px; 
            border: 2px solid #ccc; 
            background: white;
            border-radius: 8px;
        }
        
        #controls {
            margin-bottom: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .btn {
            padding: 8px 16px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .btn-primary { background: #4A90E2; color: white; }
        .btn-primary:hover { background: #357ABD; }
        
        .btn-secondary { background: #6c757d; color: white; }
        .btn-secondary:hover { background: #545b62; }
        
        #current-view {
            font-weight: bold;
            color: #333;
            margin-left: 10px;
        }
        
        #legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            border: 1px solid #ccc;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 12px;
            max-width: 200px;
        }
        
        .legend-item {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .legend-line {
            width: 20px;
            height: 2px;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <h1>Fuzzy Cognitive Map - Hierarchical View</h1>
    
    <div id="controls">
        <button class="btn btn-secondary" id="back-btn" onclick="showClusterView()" style="display: none;">
            ← Back to Clusters
        </button>
        <span id="current-view">Cluster Overview</span>
        <div style="float: right;">
            <label>Min Confidence: </label>
            <input type="range" id="confidence-slider" min="0" max="1" step="0.1" value="0.3" 
                   onchange="updateConfidenceFilter(this.value)">
            <span id="confidence-value">0.3</span>
        </div>
    </div>
    
    <div id="network"></div>
    
    <div id="legend">
        <h4>Legend</h4>
        <div class="legend-item">
            <div class="legend-color" style="background: #4A90E2;"></div>
            <span>Clusters</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #FF9500;"></div>
            <span>Concepts</span>
        </div>
        <div class="legend-item">
            <div class="legend-line" style="background: #28A745;"></div>
            <span>Positive relationship</span>
        </div>
        <div class="legend-item">
            <div class="legend-line" style="background: #DC3545;"></div>
            <span>Negative relationship</span>
        </div>
        <div style="margin-top: 10px; font-style: italic; color: #666;">
            Click clusters to explore internal concepts
        </div>
    </div>

    <script>
        // Embedded data
        const clusterData = {"iterative process": {"concepts": "iterative process", "concept_list": ["iterative process"], "type": "cluster", "node_size": 18, "label": "iterative process"}, "stack protections": {"concepts": "stack protections", "concept_list": ["stack protections"], "type": "cluster", "node_size": 18, "label": "stack protections"}, "security bypass": {"concepts": "security bypass", "concept_list": ["security bypass"], "type": "cluster", "node_size": 18, "label": "security bypass"}, "Code Pattern Analysis": {"concepts": "challenge, code challenge, source code interactions, ctf, reversing challenge, binary exploitation, challenge code, pwn challenges, exploit, code, pwntools, ctf category, ctf description, program, running binary", "concept_list": ["challenge", "code challenge", "source code interactions", "ctf", "reversing challenge", "binary exploitation", "challenge code", "pwn challenges", "exploit", "code", "pwntools", "ctf category", "ctf description", "program", "running binary"], "type": "cluster", "node_size": 60, "label": "Code Pattern Analysis"}, "Program Behavior Understanding": {"concepts": "data analysis, patterns, binary, program format, program structure, binary data, source code, python, crafting script, language, scripting, pattern, script, file signatures, libraries, source code insight, frequency analysis, assembly, encoding, finding patterns, matrix file, code patterns", "concept_list": ["data analysis", "patterns", "binary", "program format", "program structure", "binary data", "source code", "python", "crafting script", "language", "scripting", "pattern", "script", "file signatures", "libraries", "source code insight", "frequency analysis", "assembly", "encoding", "finding patterns", "matrix file", "code patterns"], "type": "cluster", "node_size": 81, "label": "Program Behavior Understanding"}, "Software Reverse Engineering": {"concepts": "neutral relationship, fresh start, reversible operations, inhibiting factors, computer software, informative description, github, emulate, memory, directed network, google results, file extensions, burp suite, available tools, get requests, running file, virtualize, program server, permissions, program response, operator, input values, useful output, decoding context, complex system, mathematical operation, unexpected behavior, heap exploitation, byte values, standard input, server, executable, packets, fuzzers, understanding, reading code, wireshark packet, full understanding, interact code, random values, mimic challenge, googling, examine code, gather output, crafting, buffer sizes, stack canary, re-approach, output structure, heap, address randomization, re-examine, balance checking, semi-structured approach, double down, testing, proof of concepts, debuggers, key steps, causal relationships, artifice, program input, distractions, standard output, black box, symbols stripped, interacting, man in the middle, user input, decompilers, decompile code, web, output, hex values, input crafting, operating system", "concept_list": ["neutral relationship", "fresh start", "reversible operations", "inhibiting factors", "computer software", "informative description", "github", "emulate", "memory", "directed network", "google results", "file extensions", "burp suite", "available tools", "get requests", "running file", "virtualize", "program server", "permissions", "program response", "operator", "input values", "useful output", "decoding context", "complex system", "mathematical operation", "unexpected behavior", "heap exploitation", "byte values", "standard input", "server", "executable", "packets", "fuzzers", "understanding", "reading code", "wireshark packet", "full understanding", "interact code", "random values", "mimic challenge", "googling", "examine code", "gather output", "crafting", "buffer sizes", "stack canary", "re-approach", "output structure", "heap", "address randomization", "re-examine", "balance checking", "semi-structured approach", "double down", "testing", "proof of concepts", "debuggers", "key steps", "causal relationships", "artifice", "program input", "distractions", "standard output", "black box", "symbols stripped", "interacting", "man in the middle", "user input", "decompilers", "decompile code", "web", "output", "hex values", "input crafting", "operating system"], "type": "cluster", "node_size": 243, "label": "Software Reverse Engineering"}, "Assumption-Based Reasoning": {"concepts": "making assumptions, knowledge beliefs, irrelevant assumptions, past experience, decision making, conclusions, open mind", "concept_list": ["making assumptions", "knowledge beliefs", "irrelevant assumptions", "past experience", "decision making", "conclusions", "open mind"], "type": "cluster", "node_size": 36, "label": "Assumption-Based Reasoning"}, "Misinterpretation & Misdirection": {"concepts": "misinterpreting, misused functions, wrong path, misleading belief, inconclusive results, perception progress, misunderstanding code, fuzzy cognitive map, misled, impersonating cookie, misleading results, jumping conclusions", "concept_list": ["misinterpreting", "misused functions", "wrong path", "misleading belief", "inconclusive results", "perception progress", "misunderstanding code", "fuzzy cognitive map", "misled", "impersonating cookie", "misleading results", "jumping conclusions"], "type": "cluster", "node_size": 51, "label": "Misinterpretation & Misdirection"}, "Code Vulnerabilities": {"concepts": "vulnerable code, vulnerable program, vulnerable, possible vulnerability, vulnerable functions, vulnerable coding, vulnerability, vulnerabilities, vulnerability identification", "concept_list": ["vulnerable code", "vulnerable program", "vulnerable", "possible vulnerability", "vulnerable functions", "vulnerable coding", "vulnerability", "vulnerabilities", "vulnerability identification"], "type": "cluster", "node_size": 42, "label": "Code Vulnerabilities"}, "Obfuscation Hunting": {"concepts": "hunt vulnerability, obfuscated code", "concept_list": ["hunt vulnerability", "obfuscated code"], "type": "cluster", "node_size": 21, "label": "Obfuscation Hunting"}, "Enabling Success": {"concepts": "success condition, success, technical factors, enabling factors", "concept_list": ["success condition", "success", "technical factors", "enabling factors"], "type": "cluster", "node_size": 27, "label": "Enabling Success"}, "Program Failure": {"concepts": "causes failure, enables success, failure, crash program, failure condition, program crashing", "concept_list": ["causes failure", "enables success", "failure", "crash program", "failure condition", "program crashing"], "type": "cluster", "node_size": 33, "label": "Program Failure"}, "Ciphertext & Crypto": {"concepts": "ciphertext output, ciphertext, crypto, encryption algorithm, encryption algorithms, cryptographic libraries", "concept_list": ["ciphertext output", "ciphertext", "crypto", "encryption algorithm", "encryption algorithms", "cryptographic libraries"], "type": "cluster", "node_size": 33, "label": "Ciphertext & Crypto"}, "Crypto Challenges": {"concepts": "crypto challenges, crypto challenge, cryptography challenge", "concept_list": ["crypto challenges", "crypto challenge", "cryptography challenge"], "type": "cluster", "node_size": 24, "label": "Crypto Challenges"}, "Security Measures": {"concepts": "security measure, protections, security measures", "concept_list": ["security measure", "protections", "security measures"], "type": "cluster", "node_size": 24, "label": "Security Measures"}, "Access Control": {"concepts": "sensitive information, privileged permissions", "concept_list": ["sensitive information", "privileged permissions"], "type": "cluster", "node_size": 21, "label": "Access Control"}, "Forensics Challenges": {"concepts": "forensics challenges, forensics", "concept_list": ["forensics challenges", "forensics"], "type": "cluster", "node_size": 21, "label": "Forensics Challenges"}, "Malicious Data": {"concepts": "malicious data, fake flags", "concept_list": ["malicious data", "fake flags"], "type": "cluster", "node_size": 21, "label": "Malicious Data"}, "Cyber Attacks": {"concepts": "cyber attacks, cyber attackers", "concept_list": ["cyber attacks", "cyber attackers"], "type": "cluster", "node_size": 21, "label": "Cyber Attacks"}};
        const conceptData = {};
        const interClusterEdges = [["stack protections", "Software Reverse Engineering", {"weight": 0.6, "confidence": 0.24000000000000005, "type": "inter_cluster", "style": "solid"}], ["security bypass", "Program Failure", {"weight": 1.0, "confidence": 0.525, "type": "inter_cluster", "style": "solid"}], ["security bypass", "Security Measures", {"weight": 0.2, "confidence": 0.4, "type": "inter_cluster", "style": "solid"}], ["Code Pattern Analysis", "Program Behavior Understanding", {"weight": 1.0, "confidence": 0.71, "type": "inter_cluster", "style": "solid"}], ["Code Pattern Analysis", "Misinterpretation & Misdirection", {"weight": 0.8, "confidence": 0.31000000000000005, "type": "inter_cluster", "style": "solid"}], ["Program Behavior Understanding", "Ciphertext & Crypto", {"weight": 1.0, "confidence": 0.64, "type": "inter_cluster", "style": "solid"}], ["Software Reverse Engineering", "Enabling Success", {"weight": 0.8, "confidence": 0.48, "type": "inter_cluster", "style": "solid"}], ["Software Reverse Engineering", "Obfuscation Hunting", {"weight": 0.4, "confidence": 0.16, "type": "inter_cluster", "style": "solid"}], ["Software Reverse Engineering", "Ciphertext & Crypto", {"weight": 0.25, "confidence": 0.125, "type": "inter_cluster", "style": "solid"}], ["Misinterpretation & Misdirection", "iterative process", {"weight": 1.0, "confidence": 0.5599999999999999, "type": "inter_cluster", "style": "solid"}], ["Code Vulnerabilities", "Misinterpretation & Misdirection", {"weight": 0.6, "confidence": 0.27, "type": "inter_cluster", "style": "solid"}], ["Code Vulnerabilities", "Assumption-Based Reasoning", {"weight": 0.6666666666666666, "confidence": 0.2333333333333333, "type": "inter_cluster", "style": "solid"}], ["Obfuscation Hunting", "Code Vulnerabilities", {"weight": 1.0, "confidence": 0.65, "type": "inter_cluster", "style": "solid"}], ["Enabling Success", "Code Pattern Analysis", {"weight": 1.0, "confidence": 0.8, "type": "inter_cluster", "style": "solid"}], ["Program Failure", "Security Measures", {"weight": -0.6666666666666666, "confidence": 0.39999999999999997, "type": "inter_cluster", "style": "solid"}], ["Program Failure", "Program Behavior Understanding", {"weight": 0.75, "confidence": 0.275, "type": "inter_cluster", "style": "solid"}], ["Crypto Challenges", "Program Behavior Understanding", {"weight": 1.0, "confidence": 0.7, "type": "inter_cluster", "style": "solid"}], ["Security Measures", "Obfuscation Hunting", {"weight": 0.2, "confidence": 0.32, "type": "inter_cluster", "style": "solid"}], ["Access Control", "Forensics Challenges", {"weight": 0.4, "confidence": 0.18, "type": "inter_cluster", "style": "solid"}], ["Access Control", "iterative process", {"weight": 0.5, "confidence": 0.15, "type": "inter_cluster", "style": "solid"}], ["Malicious Data", "Code Vulnerabilities", {"weight": -0.6, "confidence": 0.32, "type": "inter_cluster", "style": "solid"}], ["Cyber Attacks", "Access Control", {"weight": 0.4, "confidence": 0.18, "type": "inter_cluster", "style": "solid"}], ["Cyber Attacks", "Malicious Data", {"weight": 0.25, "confidence": 0.125, "type": "inter_cluster", "style": "solid"}], ["Cyber Attacks", "Security Measures", {"weight": 0.5, "confidence": 0.15, "type": "inter_cluster", "style": "solid"}]];
        const clusterConcepts = {};
        const clusterEdges = {"Code Pattern Analysis": [], "Program Behavior Understanding": [], "Software Reverse Engineering": [], "Assumption-Based Reasoning": [], "Misinterpretation & Misdirection": [], "Code Vulnerabilities": [], "Obfuscation Hunting": [], "Enabling Success": [], "Program Failure": [], "Ciphertext & Crypto": [], "Crypto Challenges": [], "Security Measures": [], "Access Control": [], "Forensics Challenges": [], "Malicious Data": [], "Cyber Attacks": []};
        
        let network;
        let currentView = 'clusters';
        let currentCluster = null;
        let minConfidence = 0.3;
        
        // Network options
        const options = {
            nodes: {
                font: { color: 'white', size: 14 },
                borderWidth: 2,
                shadow: true
            },
            edges: {
                arrows: { to: { enabled: true, scaleFactor: 1.2 } },
                shadow: true,
                smooth: { type: 'continuous' }
            },
            physics: {
                stabilization: { iterations: 100 },
                barnesHut: {
                    gravitationalConstant: -8000,
                    springConstant: 0.001,
                    springLength: 200
                }
            },
            interaction: {
                hover: true,
                selectConnectedEdges: false
            }
        };
        
        function initNetwork() {
            const container = document.getElementById('network');
            const data = getClusterViewData();
            network = new vis.Network(container, data, options);
            
            // Handle cluster clicks for drill-down
            network.on("click", function(params) {
                if (params.nodes.length > 0 && currentView === 'clusters') {
                    const clickedNode = params.nodes[0];
                    if (clusterConcepts[clickedNode]) {
                        showClusterDetail(clickedNode);
                    }
                }
            });
        }
        
        function getClusterViewData() {
            const nodes = [];
            const edges = [];
            
            // Add cluster nodes
            Object.entries(clusterData).forEach(([clusterId, data]) => {
                const concepts = data.concepts || [];
                const conceptsStr = Array.isArray(concepts) ? concepts.join(', ') : concepts;
                
                nodes.push({
                    id: clusterId,
                    label: clusterId,
                    title: `Cluster: ${clusterId}\nConcepts: ${conceptsStr}\nClick to explore internal relationships`,
                    color: '#4A90E2',
                    size: 25 + (conceptsStr.split(',').length * 2),
                    font: { color: 'white' }
                });
            });
            
            // Add inter-cluster edges
            interClusterEdges.forEach(([source, target, edgeData]) => {
                const confidence = edgeData.confidence || 1.0;
                const weight = edgeData.weight || 0;
                
                if (confidence >= minConfidence) {
                    edges.push({
                        from: source,
                        to: target,
                        color: weight > 0 ? '#28A745' : '#DC3545',
                        width: Math.abs(weight) * 3 + 1,
                        title: `${source} → ${target}\nWeight: ${weight}\nConfidence: ${confidence.toFixed(2)}`,
                        dashes: false
                    });
                }
            });
            
            return { nodes: nodes, edges: edges };
        }
        
        function getClusterDetailData(clusterId) {
            const nodes = [];
            const edges = [];
            
            // Add concept nodes for this cluster
            if (clusterConcepts[clusterId]) {
                clusterConcepts[clusterId].forEach(([conceptId, data]) => {
                    nodes.push({
                        id: conceptId,
                        label: conceptId,
                        title: `Concept: ${conceptId}\nFrom cluster: ${clusterId}`,
                        color: '#FF9500',
                        size: 20,
                        font: { color: 'white' }
                    });
                });
            }
            
            // Add intra-cluster edges
            if (clusterEdges[clusterId]) {
                clusterEdges[clusterId].forEach(([source, target, edgeData]) => {
                    const confidence = edgeData.confidence || 1.0;
                    const weight = edgeData.weight || 0;
                    
                    if (confidence >= minConfidence) {
                        edges.push({
                            from: source,
                            to: target,
                            color: weight > 0 ? '#28A745' : '#DC3545',
                            width: Math.abs(weight) * 3 + 1,
                            title: `${source} → ${target}\nWeight: ${weight}\nConfidence: ${confidence.toFixed(2)}`,
                            dashes: true
                        });
                    }
                });
            }
            
            return { nodes: nodes, edges: edges };
        }
        
        function showClusterView() {
            currentView = 'clusters';
            currentCluster = null;
            const data = getClusterViewData();
            network.setData(data);
            
            document.getElementById('back-btn').style.display = 'none';
            document.getElementById('current-view').textContent = 'Cluster Overview';
        }
        
        function showClusterDetail(clusterId) {
            currentView = 'concepts';
            currentCluster = clusterId;
            const data = getClusterDetailData(clusterId);
            network.setData(data);
            
            document.getElementById('back-btn').style.display = 'inline-block';
            document.getElementById('current-view').textContent = `Inside Cluster: ${clusterId}`;
        }
        
        function updateConfidenceFilter(value) {
            minConfidence = parseFloat(value);
            document.getElementById('confidence-value').textContent = value;
            
            // Refresh current view
            if (currentView === 'clusters') {
                showClusterView();
            } else {
                showClusterDetail(currentCluster);
            }
        }
        
        // Initialize the network when page loads
        window.onload = function() {
            initNetwork();
        };
    </script>
</body>
</html>
