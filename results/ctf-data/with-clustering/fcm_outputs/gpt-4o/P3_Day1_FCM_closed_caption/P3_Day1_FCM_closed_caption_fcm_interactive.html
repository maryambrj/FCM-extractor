
<!DOCTYPE html>
<html>
<head>
    <title>Hierarchical FCM Visualization (Unconnected nodes removed)</title>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 0; 
            padding: 20px;
            background: #f5f5f5;
        }
        
        #network { 
            width: 100%; 
            height: 600px; 
            border: 2px solid #ccc; 
            background: white;
            border-radius: 8px;
        }
        
        #controls {
            margin-bottom: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .btn {
            padding: 8px 16px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .btn-primary { background: #4A90E2; color: white; }
        .btn-primary:hover { background: #357ABD; }
        
        .btn-secondary { background: #6c757d; color: white; }
        .btn-secondary:hover { background: #545b62; }
        
        #current-view {
            font-weight: bold;
            color: #333;
            margin-left: 10px;
        }
        
        #legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            border: 1px solid #ccc;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 12px;
            max-width: 200px;
        }
        
        .legend-item {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .legend-line {
            width: 20px;
            height: 2px;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <h1>Fuzzy Cognitive Map - Hierarchical View</h1>
    
    <div id="controls">
        <button class="btn btn-secondary" id="back-btn" onclick="showClusterView()" style="display: none;">
            ← Back to Clusters
        </button>
        <span id="current-view">Cluster Overview</span>
        <div style="float: right;">
            <label>Min Confidence: </label>
            <input type="range" id="confidence-slider" min="0" max="1" step="0.1" value="0.3" 
                   onchange="updateConfidenceFilter(this.value)">
            <span id="confidence-value">0.3</span>
        </div>
    </div>
    
    <div id="network"></div>
    
    <div id="legend">
        <h4>Legend</h4>
        <div class="legend-item">
            <div class="legend-color" style="background: #4A90E2;"></div>
            <span>Clusters</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #FF9500;"></div>
            <span>Concepts</span>
        </div>
        <div class="legend-item">
            <div class="legend-line" style="background: #28A745;"></div>
            <span>Positive relationship</span>
        </div>
        <div class="legend-item">
            <div class="legend-line" style="background: #DC3545;"></div>
            <span>Negative relationship</span>
        </div>
        <div style="margin-top: 10px; font-style: italic; color: #666;">
            Click clusters to explore internal concepts
        </div>
    </div>

    <script>
        // Embedded data
        const clusterData = {"Cybersecurity Protocols": {"concepts": "rust, go, c++, c, python package, graph, static analysis, gdb, python packages", "concept_list": ["rust", "go", "c++", "c", "python package", "graph", "static analysis", "gdb", "python packages"], "type": "cluster", "node_size": 42, "label": "Cybersecurity Protocols"}, "Binary Decompilation": {"concepts": "cyber attacker, diffie-hellman, elliptic curve, cyber attacks, openssl, tls, block cipher, cipher suite, rsa", "concept_list": ["cyber attacker", "diffie-hellman", "elliptic curve", "cyber attacks", "openssl", "tls", "block cipher", "cipher suite", "rsa"], "type": "cluster", "node_size": 42, "label": "Binary Decompilation"}, "Program Debugging": {"concepts": "decompiled, decompiling, file format, ghidra, decompiling functions, decompilation, decompile, binary compilation, binwalk, binary file, compressed section", "concept_list": ["decompiled", "decompiling", "file format", "ghidra", "decompiling functions", "decompilation", "decompile", "binary compilation", "binwalk", "binary file", "compressed section"], "type": "cluster", "node_size": 48, "label": "Program Debugging"}, "Data Structures": {"concepts": "socket input, breakpoint, program execution, socket, stack determination, dynamically linked, ctf, gnu exploitation framework", "concept_list": ["socket input", "breakpoint", "program execution", "socket", "stack determination", "dynamically linked", "ctf", "gnu exploitation framework"], "type": "cluster", "node_size": 39, "label": "Data Structures"}, "Programming Languages": {"concepts": "data structure complexity, data structure, complex data structure, data structures, linked lists, labeled", "concept_list": ["data structure complexity", "data structure", "complex data structure", "data structures", "linked lists", "labeled"], "type": "cluster", "node_size": 33, "label": "Programming Languages"}, "Custom Protocols": {"concepts": "custom protocol, ide socket input, socket, protocol, protocol handling, protocol familiarity, custom protocols", "concept_list": ["custom protocol", "ide socket input", "socket", "protocol", "protocol handling", "protocol familiarity", "custom protocols"], "type": "cluster", "node_size": 36, "label": "Custom Protocols"}, "Operating Systems": {"concepts": "windows, linux, operating systems, major os, hardware, os-based linux", "concept_list": ["windows", "linux", "operating systems", "major os", "hardware", "os-based linux"], "type": "cluster", "node_size": 33, "label": "Operating Systems"}, "Decision Factors": {"concepts": "definite decisions, decision, causal factors, influential factors, decision step, decision influences, causal relationship, outcomes", "concept_list": ["definite decisions", "decision", "causal factors", "influential factors", "decision step", "decision influences", "causal relationship", "outcomes"], "type": "cluster", "node_size": 39, "label": "Decision Factors"}, "Research Methods": {"concepts": "research, frequency analysis, code analysis, automated, goal-oriented task analysis, semi-structured interview", "concept_list": ["research", "frequency analysis", "code analysis", "automated", "goal-oriented task analysis", "semi-structured interview"], "type": "cluster", "node_size": 33, "label": "Research Methods"}, "Technical Challenges": {"concepts": "prior knowledge, stack, libc version, input identification, docker file, control flow, functions, time constraint, gef, distraction, instruction patterns, teammate, multiple languages, win the ctf, loader, binary analysis, local setup, data flow, input method, details, solve script, computer visualization software, remote, firmware, remote setup, environmental variables, subject matter expert, google, dynamic modifications, optimization level, object modifications, negative arrow, issues, new york, package, arm, infrastructure, blob data, runtime type identifier, tools, fuzzy cognitive map, graph theory, dynamic introspection, hardware issues, lattice structure, signed directed graph, templated code, function labeling, templating, california, query, bare metal, aws, geography, bytecode vm, string obfuscation, challenges, buffer based, surprise, disruption, script, terminal inputs, searching, chatgtp, positive arrow, function, hex editor, architecture, node, statically compiled, san francisco, statically linked, aarch, rtti, finite architectures, compiler strings, mitigation strategy, architecture determination, dynamic variable, binary, location, configs, libc, challenge, time waster, software stack, directed graph", "concept_list": ["prior knowledge", "stack", "libc version", "input identification", "docker file", "control flow", "functions", "time constraint", "gef", "distraction", "instruction patterns", "teammate", "multiple languages", "win the ctf", "loader", "binary analysis", "local setup", "data flow", "input method", "details", "solve script", "computer visualization software", "remote", "firmware", "remote setup", "environmental variables", "subject matter expert", "google", "dynamic modifications", "optimization level", "object modifications", "negative arrow", "issues", "new york", "package", "arm", "infrastructure", "blob data", "runtime type identifier", "tools", "fuzzy cognitive map", "graph theory", "dynamic introspection", "hardware issues", "lattice structure", "signed directed graph", "templated code", "function labeling", "templating", "california", "query", "bare metal", "aws", "geography", "bytecode vm", "string obfuscation", "challenges", "buffer based", "surprise", "disruption", "script", "terminal inputs", "searching", "chatgtp", "positive arrow", "function", "hex editor", "architecture", "node", "statically compiled", "san francisco", "statically linked", "aarch", "rtti", "finite architectures", "compiler strings", "mitigation strategy", "architecture determination", "dynamic variable", "binary", "location", "configs", "libc", "challenge", "time waster", "software stack", "directed graph"], "type": "cluster", "node_size": 276, "label": "Technical Challenges"}, "Debugging Info": {"concepts": "debugging info, debugging information, debugging", "concept_list": ["debugging info", "debugging information", "debugging"], "type": "cluster", "node_size": 24, "label": "Debugging Info"}, "User-Friendly Debugger": {"concepts": "debugger, user friendliness, debugger friendliness, debugger user friendliness", "concept_list": ["debugger", "user friendliness", "debugger friendliness", "debugger user friendliness"], "type": "cluster", "node_size": 27, "label": "User-Friendly Debugger"}};
        const conceptData = {};
        const interClusterEdges = [["Cybersecurity Protocols", "Research Methods", {"weight": 0.6, "confidence": 0.44000000000000006, "type": "inter_cluster", "style": "solid"}], ["Cybersecurity Protocols", "Program Debugging", {"weight": 0.75, "confidence": 0.5625, "type": "inter_cluster", "style": "solid"}], ["Cybersecurity Protocols", "Technical Challenges", {"weight": 0.5, "confidence": 0.375, "type": "inter_cluster", "style": "solid"}], ["Cybersecurity Protocols", "User-Friendly Debugger", {"weight": 0.4, "confidence": 0.27999999999999997, "type": "inter_cluster", "style": "solid"}], ["Cybersecurity Protocols", "Data Structures", {"weight": 0.4, "confidence": 0.29, "type": "inter_cluster", "style": "solid"}], ["Binary Decompilation", "Technical Challenges", {"weight": 0.5, "confidence": 0.35, "type": "inter_cluster", "style": "solid"}], ["Binary Decompilation", "Data Structures", {"weight": 0.4, "confidence": 0.3, "type": "inter_cluster", "style": "solid"}], ["Binary Decompilation", "Program Debugging", {"weight": 0.25, "confidence": 0.1875, "type": "inter_cluster", "style": "solid"}], ["Program Debugging", "Programming Languages", {"weight": 0.75, "confidence": 0.55, "type": "inter_cluster", "style": "solid"}], ["Program Debugging", "Custom Protocols", {"weight": 1.0, "confidence": 0.7, "type": "inter_cluster", "style": "solid"}], ["Data Structures", "User-Friendly Debugger", {"weight": 0.6, "confidence": 0.43, "type": "inter_cluster", "style": "solid"}], ["Data Structures", "Decision Factors", {"weight": 0.5, "confidence": 0.3875, "type": "inter_cluster", "style": "solid"}], ["Data Structures", "Debugging Info", {"weight": 0.3333333333333333, "confidence": 0.25, "type": "inter_cluster", "style": "solid"}], ["Programming Languages", "Cybersecurity Protocols", {"weight": 0.6, "confidence": 0.45, "type": "inter_cluster", "style": "solid"}], ["Custom Protocols", "Decision Factors", {"weight": 0.8, "confidence": 0.58, "type": "inter_cluster", "style": "solid"}], ["Custom Protocols", "Program Debugging", {"weight": 0.75, "confidence": 0.6125, "type": "inter_cluster", "style": "solid"}], ["Custom Protocols", "Technical Challenges", {"weight": 0.5, "confidence": 0.375, "type": "inter_cluster", "style": "solid"}], ["Custom Protocols", "Debugging Info", {"weight": 0.5, "confidence": 0.35, "type": "inter_cluster", "style": "solid"}], ["Operating Systems", "User-Friendly Debugger", {"weight": 1.0, "confidence": 0.75, "type": "inter_cluster", "style": "solid"}], ["Operating Systems", "Decision Factors", {"weight": 0.5, "confidence": 0.3875, "type": "inter_cluster", "style": "solid"}], ["Operating Systems", "Research Methods", {"weight": 0.5, "confidence": 0.35, "type": "inter_cluster", "style": "solid"}], ["Decision Factors", "Technical Challenges", {"weight": 0.75, "confidence": 0.55, "type": "inter_cluster", "style": "solid"}], ["Decision Factors", "Data Structures", {"weight": 1.0, "confidence": 0.75, "type": "inter_cluster", "style": "solid"}], ["Research Methods", "Binary Decompilation", {"weight": 0.3333333333333333, "confidence": 0.8166666666666668, "type": "inter_cluster", "style": "solid"}], ["Research Methods", "User-Friendly Debugger", {"weight": 0.6666666666666666, "confidence": 0.5, "type": "inter_cluster", "style": "solid"}], ["Research Methods", "Custom Protocols", {"weight": 0.5, "confidence": 0.35, "type": "inter_cluster", "style": "solid"}], ["Research Methods", "Technical Challenges", {"weight": 0.2, "confidence": 0.16999999999999998, "type": "inter_cluster", "style": "solid"}], ["Technical Challenges", "Programming Languages", {"weight": 0.4, "confidence": 0.29, "type": "inter_cluster", "style": "solid"}], ["Debugging Info", "Technical Challenges", {"weight": 1.0, "confidence": 0.6833333333333332, "type": "inter_cluster", "style": "solid"}], ["Debugging Info", "Research Methods", {"weight": 0.75, "confidence": 0.5125, "type": "inter_cluster", "style": "solid"}], ["User-Friendly Debugger", "Technical Challenges", {"weight": 0.6, "confidence": 0.43, "type": "inter_cluster", "style": "solid"}]];
        const clusterConcepts = {};
        const clusterEdges = {"Cybersecurity Protocols": [], "Binary Decompilation": [], "Program Debugging": [], "Data Structures": [], "Programming Languages": [], "Custom Protocols": [], "Operating Systems": [], "Decision Factors": [], "Research Methods": [], "Technical Challenges": [], "Debugging Info": [], "User-Friendly Debugger": []};
        
        let network;
        let currentView = 'clusters';
        let currentCluster = null;
        let minConfidence = 0.3;
        
        // Network options
        const options = {
            nodes: {
                font: { color: 'white', size: 14 },
                borderWidth: 2,
                shadow: true
            },
            edges: {
                arrows: { to: { enabled: true, scaleFactor: 1.2 } },
                shadow: true,
                smooth: { type: 'continuous' }
            },
            physics: {
                stabilization: { iterations: 100 },
                barnesHut: {
                    gravitationalConstant: -8000,
                    springConstant: 0.001,
                    springLength: 200
                }
            },
            interaction: {
                hover: true,
                selectConnectedEdges: false
            }
        };
        
        function initNetwork() {
            const container = document.getElementById('network');
            const data = getClusterViewData();
            network = new vis.Network(container, data, options);
            
            // Handle cluster clicks for drill-down
            network.on("click", function(params) {
                if (params.nodes.length > 0 && currentView === 'clusters') {
                    const clickedNode = params.nodes[0];
                    if (clusterConcepts[clickedNode]) {
                        showClusterDetail(clickedNode);
                    }
                }
            });
        }
        
        function getClusterViewData() {
            const nodes = [];
            const edges = [];
            
            // Add cluster nodes
            Object.entries(clusterData).forEach(([clusterId, data]) => {
                const concepts = data.concepts || [];
                const conceptsStr = Array.isArray(concepts) ? concepts.join(', ') : concepts;
                
                nodes.push({
                    id: clusterId,
                    label: clusterId,
                    title: `Cluster: ${clusterId}\nConcepts: ${conceptsStr}\nClick to explore internal relationships`,
                    color: '#4A90E2',
                    size: 25 + (conceptsStr.split(',').length * 2),
                    font: { color: 'white' }
                });
            });
            
            // Add inter-cluster edges
            interClusterEdges.forEach(([source, target, edgeData]) => {
                const confidence = edgeData.confidence || 1.0;
                const weight = edgeData.weight || 0;
                
                if (confidence >= minConfidence) {
                    edges.push({
                        from: source,
                        to: target,
                        color: weight > 0 ? '#28A745' : '#DC3545',
                        width: Math.abs(weight) * 3 + 1,
                        title: `${source} → ${target}\nWeight: ${weight}\nConfidence: ${confidence.toFixed(2)}`,
                        dashes: false
                    });
                }
            });
            
            return { nodes: nodes, edges: edges };
        }
        
        function getClusterDetailData(clusterId) {
            const nodes = [];
            const edges = [];
            
            // Add concept nodes for this cluster
            if (clusterConcepts[clusterId]) {
                clusterConcepts[clusterId].forEach(([conceptId, data]) => {
                    nodes.push({
                        id: conceptId,
                        label: conceptId,
                        title: `Concept: ${conceptId}\nFrom cluster: ${clusterId}`,
                        color: '#FF9500',
                        size: 20,
                        font: { color: 'white' }
                    });
                });
            }
            
            // Add intra-cluster edges
            if (clusterEdges[clusterId]) {
                clusterEdges[clusterId].forEach(([source, target, edgeData]) => {
                    const confidence = edgeData.confidence || 1.0;
                    const weight = edgeData.weight || 0;
                    
                    if (confidence >= minConfidence) {
                        edges.push({
                            from: source,
                            to: target,
                            color: weight > 0 ? '#28A745' : '#DC3545',
                            width: Math.abs(weight) * 3 + 1,
                            title: `${source} → ${target}\nWeight: ${weight}\nConfidence: ${confidence.toFixed(2)}`,
                            dashes: true
                        });
                    }
                });
            }
            
            return { nodes: nodes, edges: edges };
        }
        
        function showClusterView() {
            currentView = 'clusters';
            currentCluster = null;
            const data = getClusterViewData();
            network.setData(data);
            
            document.getElementById('back-btn').style.display = 'none';
            document.getElementById('current-view').textContent = 'Cluster Overview';
        }
        
        function showClusterDetail(clusterId) {
            currentView = 'concepts';
            currentCluster = clusterId;
            const data = getClusterDetailData(clusterId);
            network.setData(data);
            
            document.getElementById('back-btn').style.display = 'inline-block';
            document.getElementById('current-view').textContent = `Inside Cluster: ${clusterId}`;
        }
        
        function updateConfidenceFilter(value) {
            minConfidence = parseFloat(value);
            document.getElementById('confidence-value').textContent = value;
            
            // Refresh current view
            if (currentView === 'clusters') {
                showClusterView();
            } else {
                showClusterDetail(currentCluster);
            }
        }
        
        // Initialize the network when page loads
        window.onload = function() {
            initNetwork();
        };
    </script>
</body>
</html>
