
<!DOCTYPE html>
<html>
<head>
    <title>Hierarchical FCM Visualization (Unconnected nodes removed)</title>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 0; 
            padding: 20px;
            background: #f5f5f5;
        }
        
        #network { 
            width: 100%; 
            height: 600px; 
            border: 2px solid #ccc; 
            background: white;
            border-radius: 8px;
        }
        
        #controls {
            margin-bottom: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .btn {
            padding: 8px 16px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .btn-primary { background: #4A90E2; color: white; }
        .btn-primary:hover { background: #357ABD; }
        
        .btn-secondary { background: #6c757d; color: white; }
        .btn-secondary:hover { background: #545b62; }
        
        #current-view {
            font-weight: bold;
            color: #333;
            margin-left: 10px;
        }
        
        #legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            border: 1px solid #ccc;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 12px;
            max-width: 200px;
        }
        
        .legend-item {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .legend-line {
            width: 20px;
            height: 2px;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <h1>Fuzzy Cognitive Map - Hierarchical View</h1>
    
    <div id="controls">
        <button class="btn btn-secondary" id="back-btn" onclick="showClusterView()" style="display: none;">
            ← Back to Clusters
        </button>
        <span id="current-view">Cluster Overview</span>
        <div style="float: right;">
            <label>Min Confidence: </label>
            <input type="range" id="confidence-slider" min="0" max="1" step="0.1" value="0.3" 
                   onchange="updateConfidenceFilter(this.value)">
            <span id="confidence-value">0.3</span>
        </div>
    </div>
    
    <div id="network"></div>
    
    <div id="legend">
        <h4>Legend</h4>
        <div class="legend-item">
            <div class="legend-color" style="background: #4A90E2;"></div>
            <span>Clusters</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #FF9500;"></div>
            <span>Concepts</span>
        </div>
        <div class="legend-item">
            <div class="legend-line" style="background: #28A745;"></div>
            <span>Positive relationship</span>
        </div>
        <div class="legend-item">
            <div class="legend-line" style="background: #DC3545;"></div>
            <span>Negative relationship</span>
        </div>
        <div style="margin-top: 10px; font-style: italic; color: #666;">
            Click clusters to explore internal concepts
        </div>
    </div>

    <script>
        // Embedded data
        const clusterData = {"node": {"concepts": "node", "concept_list": ["node"], "type": "cluster", "node_size": 18, "label": "node"}, "workflow completeness": {"concepts": "workflow completeness", "concept_list": ["workflow completeness"], "type": "cluster", "node_size": 18, "label": "workflow completeness"}, "network latency": {"concepts": "network latency", "concept_list": ["network latency"], "type": "cluster", "node_size": 18, "label": "network latency"}, "dynamic analysis": {"concepts": "dynamic analysis, dynamic variable", "concept_list": ["dynamic analysis", "dynamic variable"], "type": "cluster", "node_size": 21, "label": "dynamic analysis"}, "remote debugging": {"concepts": "remote debugging", "concept_list": ["remote debugging"], "type": "cluster", "node_size": 18, "label": "remote debugging"}, "Code & Compiler ID": {"concepts": "library, language identification", "concept_list": ["library", "language identification"], "type": "cluster", "node_size": 21, "label": "Code & Compiler ID"}, "Graph Structures": {"concepts": "graph theory, graph, directed graph", "concept_list": ["graph theory", "graph", "directed graph"], "type": "cluster", "node_size": 24, "label": "Graph Structures"}, "Graph Visualization": {"concepts": "computer visualization, graph traversal", "concept_list": ["computer visualization", "graph traversal"], "type": "cluster", "node_size": 21, "label": "Graph Visualization"}, "Data Structure Analysis": {"concepts": "data structure complexity, data structures, linked lists, pointers, lattice structure, matrix analysis, unstructured data, data flow, control flow, variable manipulation, object modification, templated code, dynamically linked, statically linked, optimization level, surprise factors, technical surprise, negative edge, neutral edge, positive edge, identification, goal-oriented task analysis, task analysis", "concept_list": ["data structure complexity", "data structures", "linked lists", "pointers", "lattice structure", "matrix analysis", "unstructured data", "data flow", "control flow", "variable manipulation", "object modification", "templated code", "dynamically linked", "statically linked", "optimization level", "surprise factors", "technical surprise", "negative edge", "neutral edge", "positive edge", "identification", "goal-oriented task analysis", "task analysis"], "type": "cluster", "node_size": 84, "label": "Data Structure Analysis"}, "Technical Tools & Collaboration": {"concepts": "file format, file signature, docker file, docker, aws, cargo, go, compiler strings, library strings, code automation, socket, socket input, tls handshake, rsa authentication, object detection, multiple languages, chatgtp, team collaboration, organizational issues, technical role, logic", "concept_list": ["file format", "file signature", "docker file", "docker", "aws", "cargo", "go", "compiler strings", "library strings", "code automation", "socket", "socket input", "tls handshake", "rsa authentication", "object detection", "multiple languages", "chatgtp", "team collaboration", "organizational issues", "technical role", "logic"], "type": "cluster", "node_size": 78, "label": "Technical Tools & Collaboration"}, "Code Analysis Methods": {"concepts": "google, code analysis, goal-oriented task, reverse engineering", "concept_list": ["google", "code analysis", "goal-oriented task", "reverse engineering"], "type": "cluster", "node_size": 27, "label": "Code Analysis Methods"}, "System Architecture & Execution": {"concepts": "hardware, hardware compatibility, architecture, architecture determination, architecture identification, decompilation, decompiling, static analysis, statically compiled binary, static compilation, software stack, firmware, operating system, application loader, execution environment, program execution, script execution, bytecode vm", "concept_list": ["hardware", "hardware compatibility", "architecture", "architecture determination", "architecture identification", "decompilation", "decompiling", "static analysis", "statically compiled binary", "static compilation", "software stack", "firmware", "operating system", "application loader", "execution environment", "program execution", "script execution", "bytecode vm"], "type": "cluster", "node_size": 69, "label": "System Architecture & Execution"}, "Memory & Security Analysis": {"concepts": "stack, stack determination, stack identification, heap management, breakpoint, compressed section, runtime decompression, opcode, instruction patterns, runtime type identifier, cipher suite, block cipher, elliptic curve", "concept_list": ["stack", "stack determination", "stack identification", "heap management", "breakpoint", "compressed section", "runtime decompression", "opcode", "instruction patterns", "runtime type identifier", "cipher suite", "block cipher", "elliptic curve"], "type": "cluster", "node_size": 54, "label": "Memory & Security Analysis"}, "Resource & Binary Handling": {"concepts": "resource allocation, binary file, string obfuscation, cloud provider, loader", "concept_list": ["resource allocation", "binary file", "string obfuscation", "cloud provider", "loader"], "type": "cluster", "node_size": 30, "label": "Resource & Binary Handling"}, "Process Optimization": {"concepts": "organizational processes, organizational process, process efficiency, process automation, iterative process, process, input identification, terminal inputs, input method, research input, research, analysis, search, query, issue, disruption, mitigation strategy", "concept_list": ["organizational processes", "organizational process", "process efficiency", "process automation", "iterative process", "process", "input identification", "terminal inputs", "input method", "research input", "research", "analysis", "search", "query", "issue", "disruption", "mitigation strategy"], "type": "cluster", "node_size": 66, "label": "Process Optimization"}, "Role Analysis": {"concepts": "role, teammate, participant, experimenter, function, function understanding, function analysis, function labeling, weight, component frequency, frequency analysis, matrix export, data section, binary analysis, arm, run, outcome, success, results", "concept_list": ["role", "teammate", "participant", "experimenter", "function", "function understanding", "function analysis", "function labeling", "weight", "component frequency", "frequency analysis", "matrix export", "data section", "binary analysis", "arm", "run", "outcome", "success", "results"], "type": "cluster", "node_size": 72, "label": "Role Analysis"}, "Data Identification": {"concepts": "hex editor, identification process", "concept_list": ["hex editor", "identification process"], "type": "cluster", "node_size": 21, "label": "Data Identification"}, "Programming Environments": {"concepts": "c, c language, c++, clang, rust, python packages, libc version, library versioning, libc, modern support, package availability, configs, templating, cfc structure, rtti, goa, rc4, diffie-hellman", "concept_list": ["c", "c language", "c++", "clang", "rust", "python packages", "libc version", "library versioning", "libc", "modern support", "package availability", "configs", "templating", "cfc structure", "rtti", "goa", "rc4", "diffie-hellman"], "type": "cluster", "node_size": 69, "label": "Programming Environments"}, "Reverse Engineering Tools": {"concepts": "gdb server, binwalk, ctf completion, ctf, gef support, ghidra, linux, major os, aarch, windows, linux os", "concept_list": ["gdb server", "binwalk", "ctf completion", "ctf", "gef support", "ghidra", "linux", "major os", "aarch", "windows", "linux os"], "type": "cluster", "node_size": 48, "label": "Reverse Engineering Tools"}, "Bare Metal Security": {"concepts": "bare metal, openssl modification", "concept_list": ["bare metal", "openssl modification"], "type": "cluster", "node_size": 21, "label": "Bare Metal Security"}, "Location Geography": {"concepts": "infrastructure location, geographical location, geography", "concept_list": ["infrastructure location", "geographical location", "geography"], "type": "cluster", "node_size": 24, "label": "Location Geography"}, "Setup Types": {"concepts": "infrastructure, local setup, remote setup", "concept_list": ["infrastructure", "local setup", "remote setup"], "type": "cluster", "node_size": 24, "label": "Setup Types"}, "Environment Variables": {"concepts": "environmental variables, environment variables", "concept_list": ["environmental variables", "environment variables"], "type": "cluster", "node_size": 21, "label": "Environment Variables"}, "Subject Expertise": {"concepts": "prior knowledge, beliefs, knowledge, subject matter expert", "concept_list": ["prior knowledge", "beliefs", "knowledge", "subject matter expert"], "type": "cluster", "node_size": 27, "label": "Subject Expertise"}, "Decision Making": {"concepts": "decision-making, decision step, decisions, decision making, decision", "concept_list": ["decision-making", "decision step", "decisions", "decision making", "decision"], "type": "cluster", "node_size": 30, "label": "Decision Making"}, "Interview Methods": {"concepts": "semi-structured interview, fuzzy cognitive map, inter-entity relationship", "concept_list": ["semi-structured interview", "fuzzy cognitive map", "inter-entity relationship"], "type": "cluster", "node_size": 24, "label": "Interview Methods"}, "Challenge Hosting": {"concepts": "challenge hosting, hosting location, challenge, cyber attacker, cyber attacks", "concept_list": ["challenge hosting", "hosting location", "challenge", "cyber attacker", "cyber attacks"], "type": "cluster", "node_size": 30, "label": "Challenge Hosting"}, "Challenge Difficulty": {"concepts": "challenge difficulty, challenge complexity", "concept_list": ["challenge difficulty", "challenge complexity"], "type": "cluster", "node_size": 21, "label": "Challenge Difficulty"}, "Problem Solving": {"concepts": "problem resolution, problem solving, solve script", "concept_list": ["problem resolution", "problem solving", "solve script"], "type": "cluster", "node_size": 24, "label": "Problem Solving"}, "Protocol Analysis": {"concepts": "protocol familiarity, protocol identification, protocol analysis", "concept_list": ["protocol familiarity", "protocol identification", "protocol analysis"], "type": "cluster", "node_size": 24, "label": "Protocol Analysis"}, "Protocol Complexity": {"concepts": "tls protocol, custom protocol, protocol complexity, custom protocols", "concept_list": ["tls protocol", "custom protocol", "protocol complexity", "custom protocols"], "type": "cluster", "node_size": 27, "label": "Protocol Complexity"}, "Influence Factors": {"concepts": "positive influence, negative influence, influence", "concept_list": ["positive influence", "negative influence", "influence"], "type": "cluster", "node_size": 24, "label": "Influence Factors"}, "User Friendliness": {"concepts": "user-friendliness, user friendliness", "concept_list": ["user-friendliness", "user friendliness"], "type": "cluster", "node_size": 21, "label": "User Friendliness"}, "Focused Self-Reflection": {"concepts": "distraction, dynamic introspection", "concept_list": ["distraction", "dynamic introspection"], "type": "cluster", "node_size": 21, "label": "Focused Self-Reflection"}, "Causal Influences": {"concepts": "influential factors, causal factors, causal factor, causal relationship", "concept_list": ["influential factors", "causal factors", "causal factor", "causal relationship"], "type": "cluster", "node_size": 27, "label": "Causal Influences"}, "Dynamic Variable Changes": {"concepts": "dynamic modifications, dynamic modification, dynamic variable modification", "concept_list": ["dynamic modifications", "dynamic modification", "dynamic variable modification"], "type": "cluster", "node_size": 24, "label": "Dynamic Variable Changes"}, "Time Efficiency": {"concepts": "time management, time waster, time constraint", "concept_list": ["time management", "time waster", "time constraint"], "type": "cluster", "node_size": 24, "label": "Time Efficiency"}, "Debugger Usability": {"concepts": "debugger friendliness, debugger usability, debugger", "concept_list": ["debugger friendliness", "debugger usability", "debugger"], "type": "cluster", "node_size": 24, "label": "Debugger Usability"}, "Debugging Details": {"concepts": "debugging process, debugging info, debugging information", "concept_list": ["debugging process", "debugging info", "debugging information"], "type": "cluster", "node_size": 24, "label": "Debugging Details"}};
        const conceptData = {};
        const interClusterEdges = [["node", "Interview Methods", {"weight": 1.0, "confidence": 0.7, "type": "inter_cluster", "style": "solid"}], ["node", "Protocol Analysis", {"weight": 1.0, "confidence": 0.6, "type": "inter_cluster", "style": "solid"}], ["node", "User Friendliness", {"weight": 0.3333333333333333, "confidence": 0.2333333333333333, "type": "inter_cluster", "style": "solid"}], ["workflow completeness", "Data Structure Analysis", {"weight": 1.0, "confidence": 0.6, "type": "inter_cluster", "style": "solid"}], ["network latency", "Reverse Engineering Tools", {"weight": -0.5, "confidence": 0.36250000000000004, "type": "inter_cluster", "style": "solid"}], ["network latency", "node", {"weight": -0.5, "confidence": 0.3, "type": "inter_cluster", "style": "solid"}], ["dynamic analysis", "Process Optimization", {"weight": 0.6666666666666666, "confidence": 0.39999999999999997, "type": "inter_cluster", "style": "solid"}], ["dynamic analysis", "Dynamic Variable Changes", {"weight": 1.0, "confidence": 0.8, "type": "inter_cluster", "style": "solid"}], ["dynamic analysis", "Setup Types", {"weight": 0.5, "confidence": 0.3, "type": "inter_cluster", "style": "solid"}], ["dynamic analysis", "Debugger Usability", {"weight": 1.0, "confidence": 0.6, "type": "inter_cluster", "style": "solid"}], ["Code & Compiler ID", "Time Efficiency", {"weight": 0.75, "confidence": 0.4625, "type": "inter_cluster", "style": "solid"}], ["Code & Compiler ID", "Influence Factors", {"weight": 1.0, "confidence": 0.675, "type": "inter_cluster", "style": "solid"}], ["Graph Visualization", "Problem Solving", {"weight": 1.0, "confidence": 0.65, "type": "inter_cluster", "style": "solid"}], ["Data Structure Analysis", "Setup Types", {"weight": -0.5, "confidence": 0.3, "type": "inter_cluster", "style": "solid"}], ["Code Analysis Methods", "workflow completeness", {"weight": 0.75, "confidence": 0.5625, "type": "inter_cluster", "style": "solid"}], ["System Architecture & Execution", "Subject Expertise", {"weight": 1.0, "confidence": 0.6375, "type": "inter_cluster", "style": "solid"}], ["System Architecture & Execution", "Programming Environments", {"weight": 1.0, "confidence": 0.6833333333333332, "type": "inter_cluster", "style": "solid"}], ["Memory & Security Analysis", "Process Optimization", {"weight": 0.6666666666666666, "confidence": 0.39999999999999997, "type": "inter_cluster", "style": "solid"}], ["Memory & Security Analysis", "node", {"weight": 0.3333333333333333, "confidence": 0.19999999999999998, "type": "inter_cluster", "style": "solid"}], ["Resource & Binary Handling", "Focused Self-Reflection", {"weight": 0.5, "confidence": 0.3, "type": "inter_cluster", "style": "solid"}], ["Process Optimization", "Reverse Engineering Tools", {"weight": 0.8, "confidence": 0.54, "type": "inter_cluster", "style": "solid"}], ["Process Optimization", "Technical Tools & Collaboration", {"weight": 0.8, "confidence": 0.52, "type": "inter_cluster", "style": "solid"}], ["Process Optimization", "System Architecture & Execution", {"weight": 1.0, "confidence": 0.6833333333333335, "type": "inter_cluster", "style": "solid"}], ["Process Optimization", "Debugging Details", {"weight": 0.8, "confidence": 0.49000000000000005, "type": "inter_cluster", "style": "solid"}], ["Role Analysis", "dynamic analysis", {"weight": 0.8, "confidence": 0.51, "type": "inter_cluster", "style": "solid"}], ["Role Analysis", "Debugging Details", {"weight": 0.6666666666666666, "confidence": 0.4333333333333333, "type": "inter_cluster", "style": "solid"}], ["Data Identification", "Resource & Binary Handling", {"weight": 1.0, "confidence": 0.8, "type": "inter_cluster", "style": "solid"}], ["Programming Environments", "Causal Influences", {"weight": 1.0, "confidence": 0.6833333333333332, "type": "inter_cluster", "style": "solid"}], ["Programming Environments", "Process Optimization", {"weight": 1.0, "confidence": 0.6, "type": "inter_cluster", "style": "solid"}], ["Programming Environments", "Protocol Analysis", {"weight": 1.0, "confidence": 0.7, "type": "inter_cluster", "style": "solid"}], ["Reverse Engineering Tools", "Decision Making", {"weight": 1.0, "confidence": 0.6499999999999999, "type": "inter_cluster", "style": "solid"}], ["Reverse Engineering Tools", "node", {"weight": 0.6666666666666666, "confidence": 0.39999999999999997, "type": "inter_cluster", "style": "solid"}], ["Reverse Engineering Tools", "Debugging Details", {"weight": 1.0, "confidence": 0.8, "type": "inter_cluster", "style": "solid"}], ["Reverse Engineering Tools", "User Friendliness", {"weight": 1.0, "confidence": 0.65, "type": "inter_cluster", "style": "solid"}], ["Reverse Engineering Tools", "Programming Environments", {"weight": 0.5, "confidence": 0.325, "type": "inter_cluster", "style": "solid"}], ["Reverse Engineering Tools", "Graph Structures", {"weight": 0.25, "confidence": 0.15, "type": "inter_cluster", "style": "solid"}], ["Bare Metal Security", "Causal Influences", {"weight": 1.0, "confidence": 0.65, "type": "inter_cluster", "style": "solid"}], ["Setup Types", "Process Optimization", {"weight": 1.0, "confidence": 0.6375000000000001, "type": "inter_cluster", "style": "solid"}], ["Environment Variables", "Interview Methods", {"weight": 0.25, "confidence": 0.2125, "type": "inter_cluster", "style": "solid"}], ["Challenge Hosting", "Causal Influences", {"weight": 0.75, "confidence": 0.5, "type": "inter_cluster", "style": "solid"}], ["Challenge Hosting", "network latency", {"weight": 1.0, "confidence": 0.7, "type": "inter_cluster", "style": "solid"}], ["Challenge Difficulty", "Influence Factors", {"weight": 0.5, "confidence": 0.35, "type": "inter_cluster", "style": "solid"}], ["Problem Solving", "remote debugging", {"weight": 1.0, "confidence": 0.675, "type": "inter_cluster", "style": "solid"}], ["Protocol Complexity", "Role Analysis", {"weight": -0.5, "confidence": 0.35, "type": "inter_cluster", "style": "solid"}], ["User Friendliness", "Data Identification", {"weight": 0.3333333333333333, "confidence": 0.26666666666666666, "type": "inter_cluster", "style": "solid"}], ["Causal Influences", "Location Geography", {"weight": 1.0, "confidence": 0.6, "type": "inter_cluster", "style": "solid"}], ["Dynamic Variable Changes", "Focused Self-Reflection", {"weight": 0.75, "confidence": 0.5249999999999999, "type": "inter_cluster", "style": "solid"}], ["Dynamic Variable Changes", "Causal Influences", {"weight": 0.5, "confidence": 0.35, "type": "inter_cluster", "style": "solid"}], ["Debugger Usability", "Memory & Security Analysis", {"weight": 0.75, "confidence": 0.575, "type": "inter_cluster", "style": "solid"}], ["Debugging Details", "Challenge Difficulty", {"weight": 0.5, "confidence": 0.6875, "type": "inter_cluster", "style": "solid"}], ["Debugging Details", "Programming Environments", {"weight": 1.0, "confidence": 0.6, "type": "inter_cluster", "style": "solid"}], ["Debugging Details", "Reverse Engineering Tools", {"weight": 0.6666666666666666, "confidence": 0.45, "type": "inter_cluster", "style": "solid"}]];
        const clusterConcepts = {};
        const clusterEdges = {"dynamic analysis": [], "Code & Compiler ID": [], "Graph Structures": [], "Graph Visualization": [], "Data Structure Analysis": [], "Technical Tools & Collaboration": [], "Code Analysis Methods": [], "System Architecture & Execution": [], "Memory & Security Analysis": [], "Resource & Binary Handling": [], "Process Optimization": [], "Role Analysis": [], "Data Identification": [], "Programming Environments": [], "Reverse Engineering Tools": [], "Bare Metal Security": [], "Location Geography": [], "Setup Types": [], "Environment Variables": [], "Subject Expertise": [], "Decision Making": [], "Interview Methods": [], "Challenge Hosting": [], "Challenge Difficulty": [], "Problem Solving": [], "Protocol Analysis": [], "Protocol Complexity": [], "Influence Factors": [], "User Friendliness": [], "Focused Self-Reflection": [], "Causal Influences": [], "Dynamic Variable Changes": [], "Time Efficiency": [], "Debugger Usability": [], "Debugging Details": []};
        
        let network;
        let currentView = 'clusters';
        let currentCluster = null;
        let minConfidence = 0.3;
        
        // Network options
        const options = {
            nodes: {
                font: { color: 'white', size: 14 },
                borderWidth: 2,
                shadow: true
            },
            edges: {
                arrows: { to: { enabled: true, scaleFactor: 1.2 } },
                shadow: true,
                smooth: { type: 'continuous' }
            },
            physics: {
                stabilization: { iterations: 100 },
                barnesHut: {
                    gravitationalConstant: -8000,
                    springConstant: 0.001,
                    springLength: 200
                }
            },
            interaction: {
                hover: true,
                selectConnectedEdges: false
            }
        };
        
        function initNetwork() {
            const container = document.getElementById('network');
            const data = getClusterViewData();
            network = new vis.Network(container, data, options);
            
            // Handle cluster clicks for drill-down
            network.on("click", function(params) {
                if (params.nodes.length > 0 && currentView === 'clusters') {
                    const clickedNode = params.nodes[0];
                    if (clusterConcepts[clickedNode]) {
                        showClusterDetail(clickedNode);
                    }
                }
            });
        }
        
        function getClusterViewData() {
            const nodes = [];
            const edges = [];
            
            // Add cluster nodes
            Object.entries(clusterData).forEach(([clusterId, data]) => {
                const concepts = data.concepts || [];
                const conceptsStr = Array.isArray(concepts) ? concepts.join(', ') : concepts;
                
                nodes.push({
                    id: clusterId,
                    label: clusterId,
                    title: `Cluster: ${clusterId}\nConcepts: ${conceptsStr}\nClick to explore internal relationships`,
                    color: '#4A90E2',
                    size: 25 + (conceptsStr.split(',').length * 2),
                    font: { color: 'white' }
                });
            });
            
            // Add inter-cluster edges
            interClusterEdges.forEach(([source, target, edgeData]) => {
                const confidence = edgeData.confidence || 1.0;
                const weight = edgeData.weight || 0;
                
                if (confidence >= minConfidence) {
                    edges.push({
                        from: source,
                        to: target,
                        color: weight > 0 ? '#28A745' : '#DC3545',
                        width: Math.abs(weight) * 3 + 1,
                        title: `${source} → ${target}\nWeight: ${weight}\nConfidence: ${confidence.toFixed(2)}`,
                        dashes: false
                    });
                }
            });
            
            return { nodes: nodes, edges: edges };
        }
        
        function getClusterDetailData(clusterId) {
            const nodes = [];
            const edges = [];
            
            // Add concept nodes for this cluster
            if (clusterConcepts[clusterId]) {
                clusterConcepts[clusterId].forEach(([conceptId, data]) => {
                    nodes.push({
                        id: conceptId,
                        label: conceptId,
                        title: `Concept: ${conceptId}\nFrom cluster: ${clusterId}`,
                        color: '#FF9500',
                        size: 20,
                        font: { color: 'white' }
                    });
                });
            }
            
            // Add intra-cluster edges
            if (clusterEdges[clusterId]) {
                clusterEdges[clusterId].forEach(([source, target, edgeData]) => {
                    const confidence = edgeData.confidence || 1.0;
                    const weight = edgeData.weight || 0;
                    
                    if (confidence >= minConfidence) {
                        edges.push({
                            from: source,
                            to: target,
                            color: weight > 0 ? '#28A745' : '#DC3545',
                            width: Math.abs(weight) * 3 + 1,
                            title: `${source} → ${target}\nWeight: ${weight}\nConfidence: ${confidence.toFixed(2)}`,
                            dashes: true
                        });
                    }
                });
            }
            
            return { nodes: nodes, edges: edges };
        }
        
        function showClusterView() {
            currentView = 'clusters';
            currentCluster = null;
            const data = getClusterViewData();
            network.setData(data);
            
            document.getElementById('back-btn').style.display = 'none';
            document.getElementById('current-view').textContent = 'Cluster Overview';
        }
        
        function showClusterDetail(clusterId) {
            currentView = 'concepts';
            currentCluster = clusterId;
            const data = getClusterDetailData(clusterId);
            network.setData(data);
            
            document.getElementById('back-btn').style.display = 'inline-block';
            document.getElementById('current-view').textContent = `Inside Cluster: ${clusterId}`;
        }
        
        function updateConfidenceFilter(value) {
            minConfidence = parseFloat(value);
            document.getElementById('confidence-value').textContent = value;
            
            // Refresh current view
            if (currentView === 'clusters') {
                showClusterView();
            } else {
                showClusterDetail(currentCluster);
            }
        }
        
        // Initialize the network when page loads
        window.onload = function() {
            initNetwork();
        };
    </script>
</body>
</html>
