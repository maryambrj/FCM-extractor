
[Experimenter 3] 15:19:31
Now we are going to cover some open-ended questions that are intended to enable us to construct what's called a fuzzy cognitive map.

[Experimenter 3] 15:19:39
related to cyber attacks and uh

[Experimenter 3] 15:19:42
you're as a cyber attacker, subject matter expert, your knowledge, beliefs, and decisions.

[Experimenter 3] 15:19:48
There are no predefined correct answers to these questions that

[Experimenter 3] 15:19:52
going to ask. It's a semi-structured interview

[Experimenter 3] 15:19:56
The process is iterative and open-ended while following a basic structure.

[Experimenter 3] 15:20:00
We may also use computer visualization software. We will. That's on the screen now.

[Experimenter 3] 15:20:05
and drawings during this process.

[Experimenter 3] 15:20:07
Please respond given your own experiences and based on your best understanding of the topic.

[Participant 3] 15:20:13
Okay.

[Experimenter 3] 15:20:15
All right. 

[Experimenter 3] 15:20:18
What we're going to start with here is I've

[Experimenter 3] 15:20:22
created a basic diagram

[Experimenter 3] 15:20:25
Which in this case is a signed directed graph. Assigned as in

[Experimenter 3] 15:20:29
Each arrow is either positive or negative.

[Experimenter 3] 15:20:33
These are phrased

[Experimenter 3] 15:20:35
in terms of definite decisions or outcomes. So you do decide to continue with the CTF, for example, and 1C.

[Experimenter 3] 15:20:44
you do ID a socket input here. 

[Participant 3] 15:20:47
Okay.

[Experimenter 3] 15:20:48
And the reason for that is because the success or the outcome, a specific outcome

[Experimenter 3] 15:20:54
either positive or negatively, you know, causes or you would interpret to cause

[Experimenter 3] 15:21:00
the next step.

[Experimenter 3] 15:21:03
So that's kind of the underlying idea. This is a structure of how you believe causes and effects work within this process.

[Experimenter 3] 15:21:11
Okay.

[Experimenter 3] 15:21:13
So I've done my best to do a quick

[Experimenter 3] 15:21:16
diagram here based on my notes to get started.

[Experimenter 3] 15:21:21
from the goal-oriented task

[Experimenter 3] 15:21:24
analysis that you just did.

[Experimenter 3] 15:21:28
So I have 1B as the first piece.

[Experimenter 3] 15:21:33
And if you'd like to look at your, please feel free.

[Experimenter 3] 15:21:37
Or your diagram. Yeah, sure.

[Experimenter 3] 15:21:41
So successfully determined architecture

[Experimenter 3] 15:21:45
And then I also have successfully determined the stack or stacks.

[Experimenter 3] 15:21:49
Does determining the architecture enable you to successfully determine the stack or are these unrelated things that you just do both of them?

[Participant 3] 15:21:56
They're unrelated. I just do both. 

[Experimenter 3] 15:21:58
All right. So in that case, this is not enabling that or making it harder. So we just

[Experimenter 3] 15:22:03
Get rid of it.

[Experimenter 3] 15:22:06
Okay. And then we have, you know, deciding in this case would be affirmatively you decide to continue.

[Experimenter 3] 15:22:12
The first thing you'd try is IDE socket input.

[Participant 3] 15:22:16
Okay, but then why are these question mark edges instead of plus edges? Because don't they 

[Experimenter 3] 15:22:22
good question 

[Participant 3] 15:22:24
because those would influence. 

[Experimenter 3] 15:22:28
So in this case uh successfully determining the architecture and successfully determining the stack or stacks

[Experimenter 3] 15:22:34
enable you to decide, but that does not mean that they positively cause you to say like okay maybe this would be easier. 

[Participant 3] 15:22:40
So they're like a neutral…

[Experimenter 3] 15:22:44
It's mixed. They could positively or they could negatively, but there's definitely a causal relationship. 

[Participant 3] 15:22:52
But they're not saying that like there's there's not that edge doesn't indicate a conditional it's just can

[Participant 3] 15:22:56
It's just an undetermined fact if it

[Participant 3] 15:22:59
influences the next state. 

[Experimenter 3] 15:23:02
Correct. 

[Participant 3] 15:23:03
Okay. 

[Experimenter 3] 15:23:04
Yeah. So if it were negative then successfully determining the architecture would

[Experimenter 3] 15:23:07
cause you to not decide, yes, I want to continue. And if it were positive, it would cause you to decide, yes, I want to continue

[Experimenter 3] 15:23:14
But either could happen. So we're leaving it at zero for now. 

[Participant 3] 15:23:18
Okay.

[Experimenter 3] 15:23:21
So then this is another kind of tricky thing we can step through is just how this makes sense.

[Experimenter 3] 15:23:27
So first, identifying the socket input

[Experimenter 3] 15:23:29
You said that if you do that, then you can skip the rest and go straight to three.

[Experimenter 3] 15:23:34
So if this is successful, so successfully

[Experimenter 3] 15:23:40
If you successfully do this, then it negatively

[Experimenter 3] 15:23:44
increases or basically decreases the chance or the need to do this 

[Participant 3] 15:23:50
yeah 

[Experimenter 3] 15:23:52
So yeah. And that basically follows this chain all the way through. 

[Participant 3] 15:23:55
All right, that makes sense. 

[Experimenter 3] 15:23:58
Right. And any one of these will enable you to successfully run the program.

[Experimenter 3] 15:24:03
Right.

[Experimenter 3] 15:24:07
You also noted that at this step, research might inform this.

[Experimenter 3] 15:24:12
I think you also said maybe research would inform one C 2, is that right? 

[Participant 3] 15:24:15
Yeah, that's correct. 

[Experimenter 3] 15:24:17
Okay. This is all just kind of getting the groundwork set up for you.

[Experimenter 3] 15:24:26
Well, actually, no, this is a zero.

[Participant 3] 15:24:30
Yeah, this is not definitive. I might decide not to go with it. 

[Experimenter 3] 15:24:35
Yeah, yeah. causal, but not in any particular direction.

[Experimenter 3] 15:24:38
All right. So then, uh.

[Experimenter 3] 15:24:41
Down here, we have, once you successfully run the program to a breakpoint.

[Experimenter 3] 15:24:48
Actually say that's to first breakpoint, right?

[Experimenter 3] 15:24:54
you decompile and then successfully understand all the functions.

[Experimenter 3] 15:24:58
Is that right? And then successfully create a solve script.

[Experimenter 3] 15:25:03
And that enables you to

[Experimenter 3] 15:25:06
win the CTF. 

[Participant 3] 15:25:07
Yeah, right.

[Experimenter 3] 15:25:09
Okay, so now that we have this basic thing set up, what I'm going to do

[Experimenter 3] 15:25:14
is go through factors that might cause

[Experimenter 3] 15:25:20
or make hard, basically enable you to succeed here or make it hard for you to do so.

[Experimenter 3] 15:25:25
So what are the most important factors that would affect your ability to successfully determine the architecture?

[Experimenter 3] 15:25:32
And some of this may feel like you've said it before and that's totally okay. Yeah.

[Participant 3] 15:25:37
So things that would make it hard.

[Experimenter 3] 15:25:41
In both cases, what are the most important causal factors for you to successfully determine the architecture?

[Participant 3] 15:25:48
No one

[Participant 3] 15:25:49
known file format.

[Participant 3] 15:25:52
Or like, you know.

[Participant 3] 15:25:53
major operating systems, so like Linux or windows

[Experimenter 3] 15:25:58
Mm-hmmm.

[Participant 3] 15:26:00
That's huge. 

[Experimenter 3] 15:26:03
Having that prior knowledge.

[Participant 3] 15:26:06
Well, not that prior knowledge, but like

[Participant 3] 15:26:09
If the challenge right if the challenge

[Participant 3] 15:26:11
is a known file format for a major OS that greatly

[Participant 3] 15:26:16
like greatly helps with greatly helps

[Participant 3] 15:26:18
successfully determine the architecture. If not.

[Participant 3] 15:26:23
you can't really determine like there's, I guess, other tools, right? Like we could run like, you know, like Binwalk on blob and those could do like a frequency analysis for certain architectures. 

[Experimenter 3] 15:26:30
Mm-hmm.

[Participant 3] 15:26:32
Or you could look at it in a hex editor and

[Participant 3] 15:26:38
see like common instruction patterns, right? Like ARM and AArch have a very like

[Participant 3] 15:26:44
distinctive like

[Participant 3] 15:26:46
you know, the unconditional execute op code

[Participant 3] 15:26:50
Before…

[Participant 3] 15:26:51
like ARM and AArch are very uh

[Participant 3] 15:26:55
are very obvious like it just stands out like if you have experience doing that, it's just very much stands out it's like oh

[Participant 3] 15:27:02
Yes, this is probably arm.

[Participant 3] 15:27:05
Another thing that would make it really hard is like unstructured like blob data, right? Like if it's just like

[Participant 3] 15:27:12
Oh, this is just a binary file with no

[Participant 3] 15:27:16
no context that would make it harder.

[Participant 3] 15:27:19
So like thinking like, you know, like the firmware type stuff where it's more bare metal, where you don't have this like OS that's going to like load the application for you.

[Participant 3] 15:27:29
that can make it more difficult.

[Experimenter 3] 15:27:32
Okay. In that case, what would you do?

[Participant 3] 15:27:35
In that case.

[Participant 3] 15:27:37
I would just…

[Participant 3] 15:27:39
you know, probably let's say I determine the architecture, it's harder it's on

[Participant 3] 15:27:43
it's unstructured. Binwalk is really the tool they'll use there on blob to kind of like figure out that stuff from frequency.

[Participant 3] 15:27:52
the component frequency analysis or viewing it in like the hex editor, right? If it's kind of unstructured, the CFC structure.

[Participant 3] 15:27:59
Binwalk, not lock.

[Participant 3] 15:28:01
like walking across the street.

[Experimenter 3] 15:28:04
Binwalk. 

[Participant 3] 15:28:06
Yeah. 

[Experimenter 3] 15:28:09
Okay.

[Participant 3] 15:28:11
Yeah. 

[Experimenter 3] 15:28:13
For a component frequency, was that what you said? 

[Participant 3] 15:28:15
Like instruction frequency.

[Experimenter 3] 15:28:17
Okay.

[Experimenter 3] 15:28:21
So that if it has unstructured data, that would positively increase, that would cause you to do this.

[Participant 3] 15:28:25
Yeah.

[Experimenter 3] 15:28:27
Okay. Which would then enable you to successfully determine the architecture. 

[Participant 3] 15:28:31
Yeah. 

[Experimenter 3] 15:28:34
Okay. Moving over to the successfully determined stack or stacks

[Experimenter 3] 15:28:38
what are the major factors in that case?

[Experimenter 3] 15:28:42
For this step.

[Experimenter 3] 15:28:44
that you need in order to be able to succeed, let's say.

[Participant 3] 15:28:50
Well, once again, if it's a well-formed binary from a known os

[Participant 3] 15:28:54
file will pick that up immediately, right? Like the file signature

[Participant 3] 15:28:59
we'll just have that like it will just it'll just tell you a lot of that

[Participant 3] 15:29:03
But the other big thing is um

[Participant 3] 15:29:07
like compiler strings will

[Participant 3] 15:29:12
be a big hint there. 

[Experimenter 3] 15:29:14
Mm-hmm.

[Participant 3] 15:29:16
as well 

[Experimenter 3] 15:29:19
Compiler strings, how do they enable that?

[Participant 3] 15:29:24
compiler strings

[Participant 3] 15:29:25
Depending on what's in the string.

[Participant 3] 15:29:28
It'll tell you if it's Rust or it's Go, right? Like it'll just it'll tell you that like, oh, this was compiled with like you know

[Participant 3] 15:29:35
cargo on this date or whatever or uh

[Participant 3] 15:29:38
like Go it's just kind of…

[Participant 3] 15:29:40
obvious like this especially for some of those library strings, they're like lib go and then like

[Participant 3] 15:29:46
Dot, dot.

[Participant 3] 15:29:48
I don't know, it's kind of clear. C++, right? If you have like the

[Participant 3] 15:29:55
C++ and C, it's harder to tell apart there, but sometimes it's possible because

[Participant 3] 15:30:00
the compiler could get stamped in.

[Participant 3] 15:30:02
And it's like, oh, I'm using you know

[Participant 3] 15:30:06
you know whatever like 

[Experimenter 3] 15:30:07
yeah

[Participant 3] 15:30:08
clings plus plus or something um

[Experimenter 3] 15:30:12
Mm-hmm.

[Experimenter 3] 15:30:13
So yeah, compiler string patterns identify language, possibly via identifying the compiler.

[Participant 3] 15:30:21
Yeah.

[Experimenter 3] 15:30:26
Okay. 

[Participant 3] 15:30:28
Things that would make it harder there would be

[Participant 3] 15:30:33
Like if the binary, you know, is stripped of like debugging information

[Participant 3] 15:30:38
Or another thing that they could have done is like done string obfuscation where then like the strings are

[Participant 3] 15:30:45
you know obfuscated in some format that and then they don't get de-obfuscated

[Participant 3] 15:30:50
till the binaries run or the strings are like in like a compressed section or something to save space so

[Participant 3] 15:30:57
That section's dynamically you know

[Participant 3] 15:31:00
the uh you know uh

[Participant 3] 15:31:02
decompress at runtime to then like load the sim, you know, load the strings in so

[Experimenter 3] 15:31:09
Sure. In that case, what might you do?

[Experimenter 3] 15:31:14
And say if it's stripped of debugging info.

[Participant 3] 15:31:17
If it was stripped of debugging info.

[Participant 3] 15:31:20
Then to figure out more, you'd probably have to go into Ghidra to see what's going on with like the control flow and uh

[Participant 3] 15:31:27
like data flow, but specifically like the control flow like

[Participant 3] 15:31:31
Do you see objects? Do you see like

[Participant 3] 15:31:35
Stuff like that going on.

[Participant 3] 15:31:40
Yeah.

[Experimenter 3] 15:31:42
to determine

[Experimenter 3] 15:31:44
the stack, basically? 

[Participant 3] 15:31:48
Yeah, determine, yeah.

[Experimenter 3] 15:31:55
Okay. String obfuscation.

[Experimenter 3] 15:31:59
what would be your mitigation strategy for that?

[Participant 3] 15:32:02
I'd probably just take that piece of knowledge and just go on to the decision step.

[Participant 3] 15:32:09
I probably just would not do the challenge.

[Participant 3] 15:32:11
be perfectly honest with that like that would be like, I've learned that. I wouldn't really try and mitigate it. 

[Experimenter 3] 15:32:15
Mm-hmm.

[Participant 3] 15:32:17
I just use that as input to the decision stuff.

[Experimenter 3] 15:32:21
So there's a direct negative relationship to deciding yes.

[Experimenter 3] 15:32:23
If the strings are obfuscated there. 

[Participant 3] 15:32:27
Yeah. Yeah.

[Experimenter 3] 15:32:29
So we have research also informing your decision, yes or no.

[Experimenter 3] 15:32:33
If the binary is stripped of debugging info before you use Ghidra, would you potentially

[Experimenter 3] 15:32:38
do any searching? Would this lead to research or would this lead to research

[Participant 3] 15:32:45
No, I think the Ghidra thing would just…

[Participant 3] 15:32:48
feed into the decision.

[Participant 3] 15:32:51
The 1C.

[Experimenter 3] 15:32:52
Okay, in a negative manner or

[Experimenter 3] 15:32:55
Basically, whatever the results are. 

[Participant 3] 15:32:57
As a query. Yeah. 

[Experimenter 3] 15:32:58
Okay. Got it.

[Experimenter 3] 15:33:02
Well, so here's a question. Does this directly inform that or does this enable you to successfully determine the stack?

[Participant 3] 15:33:08
Oh, that, yeah, sorry, that wouldn't go to there. That would go to the stack guy with the…

[Participant 3] 15:33:14
And zero weight.

[Participant 3] 15:33:16
Yeah, plus weight, right? Because it is helping me.

[Experimenter 3] 15:33:18
Yeah. Yeah. And then this is a zero because it could be either or.

[Experimenter 3] 15:33:22
Got it.

[Experimenter 3] 15:33:25
Okay.

[Experimenter 3] 15:33:30
So what types of research might you do here?

[Participant 3] 15:33:39
I would do research based on like the stack. So I've learned the architecture and the stack. And if I'm unfamiliar with those things, those are things I would search about.

[Participant 3] 15:33:49
And be like, oh, what's going on with this? You know, is this something

[Participant 3] 15:33:53
I've kind of heard before or have I not heard before so

[Participant 3] 15:33:59
Yeah, I would definitely say the stack and the architecture would positively influence research.

[Experimenter 3] 15:34:04
Okay. Successfully determining them?

[Participant 3] 15:34:08
Yeah, successfully determining them

[Participant 3] 15:34:11
But it's only if it's like new unique stuff that I'm not familiar with, though. 

[Experimenter 3] 15:34:14
I see. Yep.

[Participant 3] 15:34:16
So maybe that is a zero weight then because it's like oh

[Participant 3] 15:34:21
I won't do like, you know, if I know it's AArch, then I probably, you know, I don't care

[Participant 3] 15:34:27
But I'm not going to go search that. But if it's like, oh, I've never heard of this, you know.

[Participant 3] 15:34:33
library before, then I'll search it and then be like, oh, okay, cool. That's what's going on. 

[Experimenter 3] 15:34:38
Sure. Yep. Okay.

[Experimenter 3] 15:34:40
I think that makes sense.

[Experimenter 3] 15:34:42
Or at least I think the logic here. 

[Participant 3] 15:34:45
Yeah, the logic just seems down there okay

[Experimenter 3] 15:34:47
So are there other factors that might influence your decision of, yes, I want to continue with it aside from determining the architecture, determining the stack, and doing some research?

[Participant 3] 15:35:00
I guess one thing I didn't mention earlier is

[Participant 3] 15:35:03
a time constraint too on the uh

[Participant 3] 15:35:06
the CTF, right? Like a lot of the ones I plan have time constraints. So if it's something that's very new to me and there's only four hours left, I probably, I might.

[Participant 3] 15:35:16
you know that could that could negatively impact my like decision to do it because I was like, oh, is there something else that I could help with?

[Participant 3] 15:35:24
In the meantime.

[Participant 3] 15:35:27
you know.

[Experimenter 3] 15:35:35
So that would negatively affect your decision. 

[Participant 3] 15:35:37
Yeah.

[Experimenter 3] 15:35:39
And

[Experimenter 3] 15:35:41
that may be informed by their research, it sounds like. Yeah. And whether you successfully determine these things.

[Participant 3] 15:35:47
Yes. Okay.

[Experimenter 3] 15:35:50
But it's not guaranteed that those are positive or negative.

[Participant 3] 15:35:55
Yeah, so just yeah they might be positive or they might be negative. Got it.

[Experimenter 3] 15:35:59
Okay.

[Experimenter 3] 15:36:02
Got it.

[Experimenter 3] 15:36:04
Okay. So then down to here, successfully IDing the

[Experimenter 3] 15:36:11
that there is, I suppose, a socket input

[Experimenter 3] 15:36:14
what are some of the factors that would enable you to successfully make that identification?

[Experimenter 3] 15:36:21
Or what is the process by which that enables this to happen?

[Participant 3] 15:36:31
Well, if it's dynamically, if the binary is dynamically linked, that would be a very good positive influence because

[Participant 3] 15:36:39
then there will be there

[Participant 3] 15:36:41
you know the <unintelligible> function

[Participant 3] 15:36:43
that would get populated by the loader to be like, include socket from, you know, libc

[Participant 3] 15:36:49
If the binary is statically linked, that would definitely be a negative influence on being able to ID that or really any of the other ones down the line because it's just so much harder to, you know.

[Participant 3] 15:37:00
just search for a function. 

[Experimenter 3] 15:37:02
So dynamically being linked enables all of these things?

[Participant 3] 15:37:08
at least 2C and 2D, not really the custom protocol thing, but…

[Experimenter 3] 15:37:13
Okay.

[Experimenter 3] 15:37:19
Oops, don't need that.

[Experimenter 3] 15:37:31
Okay.

[Experimenter 3] 15:37:36
Great.

[Experimenter 3] 15:37:39
Are there other factors that affect your ability to successfully identify

[Experimenter 3] 15:37:47
need or ability to identify environmental variables, for example.

[Participant 3] 15:37:51
Yeah, I would say we should put in a, if the binary

[Participant 3] 15:37:55
is statically linked, then it would negatively be influenced. 

[Experimenter 3] 15:37:57
Sure.

[Participant 3] 15:37:58
those three or if this node captures that for you, I'm happy with that too 

[Experimenter 3] 15:38:07
yep yep so typically, um.

[Experimenter 3] 15:38:08
you can kind of run these both ways.

[Experimenter 3] 15:38:11
Okay. So, yep, yep. So in that case.

[Experimenter 3] 15:38:13
That would be correct.

[Experimenter 3] 15:38:18
Are there other factors that might influence your

[Experimenter 3] 15:38:21
either need or success in identifying environmental variables.

[Experimenter 3] 15:38:26
environment variables.

[Experimenter 3] 15:38:28
If no, then… 

[Participant 3]
Yeah, no, I would say no for those. It really is.

[Participant 3] 15:38:34
Just searching for library stuff for me to share.

[Experimenter 3] 15:38:38
Same question for terminal inputs, configs.

[Participant 3] 15:38:43
Yeah, no, same idea. 

[Experimenter 3] 15:38:45
Okay.

[Participant 3] 15:38:47
custom protocols would be

[Participant 3] 15:38:49
If the optimization level of the binary is really high, that can mess stuff up.

[Participant 3] 15:38:59
And if they have some amount of like uh

[Participant 3] 15:39:03
Another thing that could negatively influence that is if they have some type of like run, like in C++, it's like runtime

[Participant 3] 15:39:10
type identifier stuff like RTTI if

[Participant 3] 15:39:13
they're doing something like that or something, you know, the other, I believe Goa is something similar. Like if they're doing something like that, like templating, right?

[Participant 3] 15:39:21
It just makes this insanely difficult challenge because so much of that's dynamic.

[Participant 3] 15:39:27
it's so hard to tell

[Participant 3] 15:39:30
at this point where we're just statically analyzing the code, what's going on.

[Experimenter 3] 15:39:36
Got it. Got it.

[Experimenter 3] 15:39:40
Okay. Are there any other factors that

[Experimenter 3] 15:39:45
significantly may influence this uh

[Experimenter 3] 15:39:48
the need or success in identifying custom protocols.

[Participant 3] 15:39:54
No, not really.

[Experimenter 3] 15:39:56
Okay.

[Experimenter 3] 15:39:58
So let's move on to step three here, successfully running the program to a first an established breakpoint.

[Experimenter 3] 15:40:08
Aside from these

[Experimenter 3] 15:40:10
you know identification of the inputs

[Experimenter 3] 15:40:12
Are there other factors that enable you to successfully run the program to the first breakpoint?

[Experimenter 3] 15:40:19
And research.

[Experimenter 3] 15:40:23
Which I'm going to label as Google.

[Experimenter 3] 15:40:25
ChatGTP.

[Participant 3] 15:40:32
So since this is

[Participant 3] 15:40:36
Since architecture did not influence, but then it positively influenced this.

[Participant 3] 15:40:40
Does these still carry down in the graph directly? Like, is it one of those things where like.

[Participant 3] 15:40:45
Oh, you know, you know, you know, it's like, it's kind of like a

[Participant 3] 15:40:50
you know the stuff that flows all the way in or is it kind of like once we get to a box, we don't look at what comes into the box is like carrying on? 

[Experimenter 3] 15:40:57
So yeah, these are these are causal all the way down.

[Participant 3] 15:41:01
Okay, then in that case, then no. But like, it's definitely like stuff where like, hey, if it's an easy architecture and easy stack to run, like that will influence how easy it is to run. But those arrows already…

[Participant 3] 15:41:13
flow in correctly so

[Participant 3] 15:41:16
Then we don't have to connect them. 

[Experimenter 3] 15:41:19
They do, but there's two ways you could think of it. One is that successfully determining the architecture enabled you to get to this step.

[Experimenter 3] 15:41:24
The other is that

[Experimenter 3] 15:41:26
details related to the architecture directly influence your success at this step too.

[Experimenter 3] 15:41:30
So two different things. Would you say that the architectural details

[Experimenter 3] 15:41:36
actually directly affect your success in running the program.

[Participant 3] 15:41:44
No. 

[Participant 3] 15:41:48
Okay. Same question for the stack. 

[Participant 3] 15:41:51
Yeah, because this is just determining the stack. It's not specifying. If we had these broken out to like, it is this type of software stack

[Participant 3] 15:41:58
Then I could justify drawing those like, you know, concrete arrows. 

[Experimenter 3] 15:42:02
Sure. That sounds like a new node then. 

[Participant 3] 15:42:05
Okay. Yeah. Then I would say, uh.

[Participant 3] 15:42:08
Yeah, if it's Linux.

[Participant 3] 15:42:10
probably pretty high chance.

[Participant 3] 15:42:15
And then if the binary is statically compiled.

[Participant 3] 15:42:18
pretty high chance.

[Experimenter 3] 15:42:21
statically instead of dynamically? 

[Participant 3] 15:42:23
Yeah. 

[Experimenter 3] 15:42:24
Okay.

[Participant 3] 15:42:26
I don't need anything else, you know, there's just

[Participant 3] 15:42:29
It's the architecture match, yes, okay.

[Participant 3] 15:42:37
If they provided a Docker file

[Participant 3] 15:42:42
Probably pretty high.

[Participant 3] 15:42:44
As well.

[Experimenter 3] 15:42:57
Okay. 

[Participant 3] 15:42:58
Yeah.

[Experimenter 3] 15:42:59
Great.

[Experimenter 3] 15:43:01
Down to step four, back to decompilation, where you're successfully understanding and then labeling all of the functions.

[Experimenter 3] 15:43:10
What factors beyond

[Experimenter 3] 15:43:12
successfully running the program to a break point.

[Experimenter 3] 15:43:17
enable or impede your success at this step.

[Participant 3] 15:43:21
enable is like 

[Participant 3] 15:43:23
is it a protocol I'm familiar with?

[Participant 3] 15:43:26
like if it's like…

[Participant 3] 15:43:27
a familiar protocol

[Participant 3] 15:43:29
going to be pretty easy.

[Participant 3] 15:43:34
the…

[Participant 3] 15:43:37
The debugger friendliness as well is going to be a big thing.

[Participant 3] 15:43:42
Like, are they…

[Participant 3] 15:43:44
if the program is

[Participant 3] 15:43:46
primarily like buffer based, probably pretty easy. If it's like a bunch of like, oh, you need all these objects and you, you know, structs and structs and structs it's

[Participant 3] 15:43:55
It really is like, or it's dealing with something with linked lists where like, you know, now you're like dereferencing every node to like get to the one you're interested in. That'd make it really hard. So maybe like.

[Participant 3] 15:44:04
data structures at play can make it very difficult.

[Experimenter 3] 15:44:09
Mm-hmm.

[Participant 3] 15:44:14
Oh.

[Experimenter 3] 15:44:16
Okay. Are there other things, other factors?

[Experimenter 3] 15:44:22
Are there issues that would uh

[Experimenter 3] 15:44:26
influence your familiarity with the protocol.

[Experimenter 3] 15:44:30
Or the user friendliness of the debugger or the data structure in it.

[Experimenter 3] 15:44:33
That is to say, are there upstream things from these?

[Participant 3] 15:44:37
Let me think. Upstream things. 

[Experimenter 3] 15:44:41
Mm-hmm.

[Participant 3] 15:44:51
Debugger is user-friendly.

[Participant 3] 15:44:54
I would say is the architecture like

[Participant 3] 15:44:57
Debugger is user-friendly if it's like

[Participant 3] 15:45:00
you know, is the architecture

[Participant 3] 15:45:04
supported by GEF.

[Participant 3] 15:45:08
G, capital G, uh.

[Participant 3] 15:45:10
It's like GNU exploitation framework or something it stands for or something like that.

[Experimenter 3] 15:45:15
Okay. That influences whether the debugger is user friendly. 

[Participant 3] 15:45:18
Yeah. 

[Experimenter 3] 15:45:19
Okay. 

[Participant 3] 15:45:21
For sure. 

[Experimenter 3] 15:45:22
Okay.

[Participant 3] 15:45:23
It's nice because then you can give it like a drawer file and unpack your structures nicely for you.

[Experimenter 3] 15:45:28
Are there…

[Experimenter 3] 15:45:31
upstream factors that

[Experimenter 3] 15:45:35
inform the likelihood of the data structure being

[Experimenter 3] 15:45:39
complex or painful or cumbersome.

[Participant 3] 15:45:44
Not really. That's just something you discover as you reverse.

[Experimenter 3] 15:45:50
Okay. So, um.

[Experimenter 3] 15:45:50
So let's assume that you've successfully understood and labeled all the functions. And so you're moving on to creating the solve script.

[Experimenter 3] 15:45:58
what factors enable your success in creating the solve script?

[Participant 3] 15:46:08
Is there a Python package

[Participant 3] 15:46:12
for, you know, for

[Participant 3] 15:46:15
the majority are there Python packages available for like the functionality for like the

[Participant 3] 15:46:21
input

[Participant 3] 15:46:23
you know the the input method that's being accepted, you know, input method that's chosen

[Participant 3] 15:46:28
And then I would also add like another node where you can combine them that's like

[Participant 3] 15:46:33
Are there Python packages

[Participant 3] 15:46:35
to deal with the protocol

[Participant 3] 15:46:37
that's being, you know, being used or something.

[Experimenter 3] 15:46:52
And is that because the solve script is typically Python?

[Participant 3] 15:46:55
Yeah, that's just because that's what I try and write everything in.

[Participant 3] 15:46:59
Makes it easy, yes.

[Participant 3] 15:47:04
things that could make that hard

[Participant 3] 15:47:07
would be…

[Participant 3] 15:47:11
you know having to do like dynamic

[Participant 3] 15:47:14
modifications so like

[Participant 3] 15:47:16
Say you found the way to solve this was kind of like when you get to a function, you manipulate some variables using GDB.

[Participant 3] 15:47:23
obviously tying that stuff in

[Participant 3] 15:47:25
makes it a little bit more complicated because you either have to like

[Participant 3] 15:47:29
you know use GDB server and some type of GDB plugin to actually like do the debugging for you

[Participant 3] 15:47:35
or you as the human have to have more of like the setup where then like you print out like an input statement and you're like.

[Participant 3] 15:47:41
Yo, go do this in the program. And then you go do it and then you press enter and then you let your solve script continue.

[Participant 3] 15:47:49
That can make it harder to create a successful solve script because

[Participant 3] 15:47:53
now you're changing the program.

[Experimenter 3] 15:47:56
Is this expressly variable modifications or any sort of dynamic code modifications?

[Participant 3] 15:48:02
It could be any sort of dynamic. It could be code as well.

[Experimenter 3] 15:48:07
object, any of those things. 

[Participant 3] 15:48:08
Yeah.

[Experimenter 3] 15:48:09
Okay. And what factors would increase the probability of that uh

[Experimenter 3] 15:48:15
being required.

[Participant 3] 15:48:17
If it's a custom protocol.

[Experimenter 3] 15:48:21
Got it.

[Experimenter 3] 15:48:25
Okay. So if you successfully identify custom protocols that increases this chance.

[Participant 3] 15:48:30
Yeah.

[Experimenter 3] 15:48:37
Okay.

[Experimenter 3] 15:48:39
Are there other factors that

[Experimenter 3] 15:48:42
are kind of core causal factors for successfully your ability to successfully create

[Experimenter 3] 15:48:49
a Python solve script.

[Participant 3] 15:48:50
No.

[Experimenter 3] 15:48:51
Okay. And is there any…

[Experimenter 3] 15:48:53
other factor between creating the solve script and winning the CTF?

[Experimenter 3] 15:49:01
Well, completing the CTF.

[Participant 3] 15:49:04
Well, there's always the issue of your remote

[Participant 3] 15:49:09
your setup and the remote do not match.

[Participant 3] 15:49:14
So, uh.

[Participant 3] 15:49:15
Your solve script works locally but does not work remotely and uh

[Participant 3] 15:49:19
Then you have to debug that.

[Experimenter 3] 15:49:22
Are there factors that increase the chance of that happening?

[Participant 3] 15:49:29
Yeah, if you have to do more dynamic variable modification and stuff, that really does increase that.

[Experimenter 3] 15:49:39
Are there other things besides custom protocols that might increase the chance of having to do this?

[Participant 3] 15:49:49
It could also just be normal protocols. They could just be the more complex normal protocols. Like, I'm sorry, like TLS is insane like once you consider like all the options and like

[Participant 3] 15:50:01
fields and intricacies like

[Participant 3] 15:50:03
that can get really insane. I remember doing a challenge one time where it was just basic TLS. You had TLS handshake to a server.

[Participant 3] 15:50:10
What they did is they defined their own new custom cipher suite.

[Participant 3] 15:50:14
So like you had to like…

[Participant 3] 15:50:17
Basically, you know.

[Participant 3] 15:50:20
modify and hook OpenSSL to do like their fake like

[Participant 3] 15:50:25
you know modern you know whatever they called it it was like, you know, it was elliptic curve but like

[Participant 3] 15:50:32
with a twist and then like

[Participant 3] 15:50:33
It was like elliptic curve, Diffie-Hellman for your ephemeral key, but then you used like RSA as your authentication signature algorithm.

[Participant 3] 15:50:42
And then they were running it with like, you know.

[Participant 3] 15:50:45
some like random block cipher you know like rc4 so like it wasn't natively supported so you had to like

[Participant 3] 15:50:53
modify whatever OpenSSL library you're using to like

[Participant 3] 15:50:56
put in hooks to have the right ciphers in the right places so

[Experimenter 3] 15:51:01
Would that potentially be also informed by a complex data structure?

[Experimenter 3] 15:51:06
Or is it really just that it's the protocols? 

[Participant 3] 15:51:08
To me, that's the protocol. Complex data structure I'm thinking about is the like.

[Participant 3] 15:51:11
There's other REA challenges where like they'll be like, oh, I'm going to do this like

[Participant 3] 15:51:16
you know, you're going to

[Participant 3] 15:51:18
The flags in this binary and I've stored it as this like, you know, lattice structure or whatever. And then this lattice structure gets loaded out of memory as an array.

[Participant 3] 15:51:27
into this like directed you know graph

[Participant 3] 15:51:29
And then what it's going to do is then like traverse around the nodes of the graph.

[Participant 3] 15:51:33
So then you have like, you know, graph theory in there and then you're trying to like, you know, reverse whatever this weird like

[Participant 3] 15:51:39
you know lattice matrix or like or some graph or something and it's just like

[Participant 3] 15:51:45
It's a pain, you know, pointers everywhere and

[Participant 3] 15:51:48
stuff so 

[Experimenter 3] 15:51:50
Okay. All right. Well, then we can leave that be. So the last kind of round of things to run through, additional nodes and edges we want to add here.

[Experimenter 3] 15:52:00
are related to the main steps and the main factors. And essentially, it's a two-parter because we'll want to be a bit speedy here.

[Experimenter 3] 15:52:09
Imagine an unexpected surprise or a distraction and disruption.

[Experimenter 3] 15:52:14
So either surprise or something that causes you to waste a lot of time at this step.

[Experimenter 3] 15:52:18
What might that be? And we'll start with successfully determining the architecture.

[Participant 3] 15:52:24
So something that would cause me to waste a lot of time. 

[Experimenter 3] 15:52:31
A surprise or something that would cause you waste a lot of time. Yeah. Ideally, if you can have answers for both, but 

[Participant 3] 15:52:35
A surprise would be like an architecture that's identifiable but like

[Participant 3] 15:52:38
like never used like for example alpha. That was something in like end cuts. Never heard of that before.

[Participant 3] 15:52:44
Kind of insane.

[Participant 3] 15:52:47
It existed it's like, but it existed in like the 70s so like

[Participant 3] 15:52:52
Modern support, non-existent.

[Experimenter 3] 15:52:54
So does that influence your ability to determine the architecture or

[Experimenter 3] 15:52:58
it really just is a negative

[Experimenter 3] 15:53:02
influences your decision of yes to continue. 

[Participant 3] 15:53:07
Oh, I guess it negatively influences that. Determining the architecture. Frequency analysis might fail.

[Participant 3] 15:53:12
then is really the big thing is like frequency analysis is not a guarantee

[Participant 3] 15:53:16
with determining it. So there might not be enough code to determine the frequency, right?

[Experimenter 3] 15:53:23
Yeah. And would you consider that a surprise or a time waster?

[Participant 3] 15:53:33
A time waster because then you actually have to like, you know, go dig into you know, the binary more yourself

[Participant 3] 15:53:37
Yeah, I don't really feel like there's a surprise here at this step because the amount of architectures is just kind of finite.

[Experimenter 3] 15:53:45
and um

[Experimenter 3] 15:53:47
This is enabled basically by doing frequency analysis, so using Binwalk et all.

[Experimenter 3] 15:53:53
Right. 

[Experimenter 3] 15:53:55
Okay. Coming over to successfully determining the stack or stacks involved.

[Experimenter 3] 15:54:00
Are there any unexpected surprises or

[Experimenter 3] 15:54:03
or time wasters that

[Experimenter 3] 15:54:05
You can imagine might occur when you're trying to successfully determine the stack.

[Participant 3] 15:54:11
Um surprises.

[Participant 3] 15:54:23
a surprise might be a surprise

[Participant 3] 15:54:26
Sometimes what people will do is like

[Participant 3] 15:54:28
you can have like, at least for like a statically compiled binary right like or like Rust, right? Like you can unsafe in a massive amount of code and then like statically compile it in. And so what'll happen is you'll have like Rust and C in a binary.

[Participant 3] 15:54:42
So like.

[Participant 3] 15:54:44
it can it can really like like that could be a surprise for like, oh, you have multiple languages now. So it makes it just

[Participant 3] 15:54:50
Since this is very much a binary question of like, is it this stack or not, then when you have those multiple ones, it's like.

[Participant 3] 15:54:56
Okay, what did they do to get these things combined together? 

[Experimenter 3] 15:55:01
So that surprise and a time waster? 

[Participant 3] 15:55:02
Yeah.

[Experimenter 3] 15:55:04
Okay. And that…

[Experimenter 3] 15:55:07
impedes, does that impede your ability to determine the stack or is it you kind of get you

[Experimenter 3] 15:55:13
do successfully determine it, but then you just can't figure out whether to continue.

[Participant 3] 15:55:17
I just feel like then it just wastes time. Like, that's the thing like it doesn't

[Participant 3] 15:55:20
It doesn't negatively affect. I'll get there. I'll figure out what's going on stack wise. Mm-hmm.

[Experimenter 3] 15:55:26
Okay, so it does affect your ability to determine the stack.

[Participant 3] 15:55:29
Yeah. Okay. Because it wastes time. 

[Experimenter 3] 15:55:34
Yep. Got it. Okay.

[Experimenter 3] 15:55:37
Going down to successfully identifying, well, determining that there is an identifying socket input.

[Experimenter 3] 15:55:44
Are there any surprises or time wasters that might emerge at that step?

[Participant 3] 15:55:49
No, that's pretty cut and dry. That's fast. Sure.

[Experimenter 3] 15:55:52
How about identifying environment variables?

[Participant 3] 15:55:54
That's fast. Really all those are just like boom, boom, boom. 

[Experimenter 3] 15:55:58
Rather straightforward. 

[Participant 3] 15:55:59
Yeah. 

[Experimenter 3] 15:56:01
Okay. No surprises expected?

[Participant 3] 15:56:12
So for this custom protocol one, if they're implementing their own bytecode VM, that can

[Participant 3] 15:56:18
that can be a surprise because it'll look like there's not a lot of code, but then you're like, oh shoot, this giant blob in the data section is actually like bytecode. That can be a surprise.

[Experimenter 3] 15:56:31
And that affects your ability to identify a custom protocol?

[Experimenter 3] 15:56:34
Or it affects your ability to successfully. 

[Participant 3] 15:56:40
Yeah, it'll it'll also affect this. But it also affects my ability to ID the protocol because, well, now it's this like bytecode

[Participant 3] 15:56:45
So it's like, oh, I have to figure out what that bytecode's doing to figure out if there's like custom protocols.

[Experimenter 3] 15:56:52
So it negatively affects your ability to run the program as well.

[Participant 3] 15:56:53
Yeah.

[Experimenter 3] 15:56:54
Okay.

[Participant 3] 15:56:55
But I would honestly say it probably actually is a positive thing to the ID protocols.

[Participant 3] 15:56:59
Because it's one of those things where it's like.

[Participant 3] 15:57:02
Oh, if you're implementing your own custom bytecode VM, it's custom code, right? Like that's where the interesting stuff's going to be.

[Participant 3] 15:57:09
Nobody's going to go out of their way to like do something like that to like, you know, whatever, you know, read a file.

[Experimenter 3] 15:57:18
Okay. So yeah, that makes running the program harder, but you can successfully say at that point that there's a custom protocol.

[Participant 3] 15:57:25
Yeah. 

[Experimenter 3] 15:57:29
Okay. Are there other surprises perhaps related to any of these factors on the left side here?

[Experimenter 3] 15:57:35
or just directly that

[Experimenter 3] 15:57:38
would disrupt your ability to successfully run the program.

[Participant 3] 15:57:43
a time waster for the OS-based Linux thing is

[Participant 3] 15:57:46
like the like figuring out the right libc version you need

[Participant 3] 15:57:49
Especially if it's like um

[Participant 3] 15:57:52
something related to like the heap or something since those change that changes between the C versions.

[Experimenter 3] 15:57:58
Okay.

[Experimenter 3] 15:58:05
or their need to determine libc version at all.

[Participant 3] 15:58:09
No, it's like a time waste because you have to go find that library version to run against that specific library version. So that can take time.

[Experimenter 3] 15:58:17
Okay.

[Experimenter 3] 15:58:25
So if the OX is Linux based, that increases the probability of

[Experimenter 3] 15:58:29
having to do this, which then

[Experimenter 3] 15:58:32
has a negative

[Experimenter 3] 15:58:34
Relationship on unsuccessfully running the program. Okay.

[Participant 3] 15:58:40
Did you get that arrow to blue?

[Experimenter 3] 15:58:40
It is in there. Oh, the blue? Yeah.

[Experimenter 3] 15:58:44
And also this all exports as a matrix

[Experimenter 3] 15:58:46
Fortunately, so it doesn't have to be perfectly legible, thankfully.

[Experimenter 3] 15:58:52
So down to decompiling and successfully understanding all the functions once you have run the program.

[Experimenter 3] 15:58:58
Any surprises or time wasters that come to mind either with that or with these factors that

[Experimenter 3] 15:59:04
that cause it to succeed or fail.

[Participant 3] 15:59:10
a big time waste would be if they had templated code. That would just makes it take a lot longer.

[Participant 3] 15:59:18
Odds are the functionality is probably not that advanced, right? Like, you know, if they're in

[Participant 3] 15:59:24
some implementer template. It just takes a lot of time then because it's a lot more like dynamic introspection to figure out what's

[Participant 3] 15:59:32
you know what is this?

[Participant 3] 15:59:35
actually pointing to at that point in time. So 

[Experimenter 3] 15:59:39
Got it. All right. And would that be related to any of the things over here?

[Participant 3] 15:59:43
Or is this its own thing?

[Experimenter 3] 15:59:45
Like, does this increase the chance of or decrease your chance of your familiarity with the protocol or user friendliness of the debugger or the complexity of the data structure?

[Participant 3] 15:59:57
No, just wastes time. Just wastes time.

[Experimenter 3] 16:00:00
And then I'll make sure to put in time waster.

[Experimenter 3] 16:00:04
Okay.

[Experimenter 3] 16:00:05
Same question for surprises or time wasters. For successfully creating the solve script once you have decompiled and labeled and understood all the functions.

[Experimenter 3] 16:00:19
Aside from dynamic variable code or object modifications being required.

[Participant 3] 16:00:27
Not really, like…

[Participant 3] 16:00:30
Yeah, I wouldn't say it's a surprise or a time waste if a package doesn't exist.

[Participant 3] 16:00:36
You know, if a package doesn't exist, then you're writing more code for it. But this isn't

[Participant 3] 16:00:41
To me, that's not a time waster. It's not like

[Experimenter 3] 16:00:42
Sure.

[Participant 3] 16:00:43
Gosh, I wish this was automated. It's just like, well, somebody has to do it the first time.

[Experimenter 3] 16:00:50
Down here to

[Experimenter 3] 16:00:52
Local and remote setup do not match

[Experimenter 3] 16:00:54
as you said, generally caused by

[Experimenter 3] 16:00:57
dynamic modifications being required.

[Experimenter 3] 16:01:00
If I'm correct. 

[Participant 3] 16:01:01
Yep.

[Experimenter 3] 16:01:03
Are there any things that

[Experimenter 3] 16:01:05
might surprise you and lead to that happening aside from this or

[Experimenter 3] 16:01:11
any surprises that might cause this in your experience?

[Participant 3] 16:01:15
some…

[Participant 3] 16:01:17
uh…

[Participant 3] 16:01:19
Sometimes your friends can run the script and it will work against the remote, but when you run it, it doesn't. So it's also like a

[Participant 3] 16:01:26
you know that could be a time waste where it's like, it could just be your hardware and you need like a teammate to have run it.

[Participant 3] 16:01:42
So you pass it off to them, they run it and it just works. Or sometimes it's like where you are in the world, right? Like sometimes if the CTF is like

[Participant 3] 16:01:50
you know, the infrastructure

[Participant 3] 16:01:52
is hosted in California.

[Participant 3] 16:01:54
It helps to have the person who's in San Francisco run it where if you're pinging through, you know.

[Participant 3] 16:02:01
New York, AWS.

[Participant 3] 16:02:03
you know uh you know it just takes too long or something.

[Experimenter 3] 16:02:08
So…

[Experimenter 3] 16:02:11
So is that generally the case that your location in the world being different from the CTF?

[Experimenter 3] 16:02:16
geography. where it's hosted?

[Participant 3] 16:02:16
Yeah, for some challenges that could that could actually be like the difference

[Participant 3] 16:02:24
Just unfortunate, but…

[Experimenter 3] 16:02:29
That is interesting.

[Experimenter 3] 16:02:31
And that may be, that would come as a surprise, you'd say?

[Participant 3] 16:02:35
Yeah. 

[Experimenter 3] 16:02:36
And same with your hardware isn't working?

[Participant 3] 16:02:39
Yeah, that's more of a time waster one because it's like you should have just let somebody else run it. It's like

[Experimenter 3] 16:02:46
Okay. Well, I think we've got it.

[Experimenter 3] 16:02:48
Are there any things on this graph as you look at it, are there any

[Participant 3] 16:02:53
influential factors or issues and details that are important that are missing and you'd like to note.

[Participant 3] 16:03:05
I'm sure there are some, but…

[Participant 3] 16:03:10
This feels complete enough.

[Experimenter 3] 16:03:12
Okay, great.
